#!/usr/bin/env python3
# -*- mode:python -*-

# $PIP_license:$
# $RIKEN_copyright:$
# $PIP_VERSION:$
#
# $Author: Atsushi Hori (R-CCS) mailto: ahori@riken.jp or ahori@me.com
# $

from __future__ import print_function
import os
import signal
import sys
import subprocess as sp

try :
    import fnmatch as fnm
    flag_fnmatch = True
except:
    flag_fnmatch = False


wtab = { 'USER':  8,
         'TT':    8,
         'TTY':   8,
         'START': 7 }

cmdself = os.path.basename( sys.argv.pop(0) )

check_gen    = None
check_out    = None
check_output = None

def print_usage( errmsg ):
    global check_gen, check_out, check_output
    print( cmdself+':', errmsg, file=sys.stderr )
    if check_gen != None or check_out != None:
        print( cmdself+':', errmsg, file=check_output )
    print( 'Usage:', cmdself, '[a][u][x] <PIPS_OPTIONS> [<CMDS>]', file=sys.stderr )
    sys.exit( 1 )

def eprint( msg ):
    global check_gen, check_out, check_output
    print( cmdself.upper()+':', msg, file=sys.stderr )
    if check_gen != None or check_out != None:
        print( cmdself.upper()+':', msg, file=check_output )

def ex_print( msg ):
    eprint( msg )
    try:
        if check_out != None:
            check_output.close()
    except:
        pass
    sys.exit( 1 )

sigtab = [ ( 'HUP',   signal.SIGHUP  ), # 1
           ( 'INT',   signal.SIGINT  ), # 2
           ( 'QUIT',  signal.SIGQUIT ), # 3
           ( 'ILL',   signal.SIGILL  ), # 4
           ( 'TRAP',  signal.SIGTRAP ), # 5
           ( 'ABRT',  signal.SIGABRT ), # 6
           ( 'BUS',   signal.SIGBUS  ), # 7
           ( 'FPE',   signal.SIGFPE  ), # 8
           ( 'KILL',  signal.SIGKILL ), # 9
           ( 'USR1',  signal.SIGUSR1 ), # 10
           ( 'SEGV',  signal.SIGSEGV ), # 11
           ( 'USR2',  signal.SIGUSR2 ), # 12
           ( 'PIPE',  signal.SIGPIPE ), # 13
           ( 'ALRM',  signal.SIGALRM ), # 14
           ( 'TERM',  signal.SIGTERM ), # 15
           ( 'CHLD',  signal.SIGCHLD ), # 17
           ( 'CLD',   signal.SIGCHLD ), # 17
           ( 'CONT',  signal.SIGCONT ), # 18
           ( 'STOP',  signal.SIGSTOP ), # 19
           ( 'TSTP',  signal.SIGTSTP ), # 20
           ( 'TTIN',  signal.SIGTTIN ), # 21
           ( 'TTOU',  signal.SIGTTOU ), # 22
           ( 'URG',   signal.SIGURG  ), # 23
           ( 'XCPU',  signal.SIGXCPU ), # 24
           ( 'XFSZ',  signal.SIGXFSZ ), # 25
           ( 'VTALRM', signal.SIGVTALRM ), # 26
           ( 'PROF',  signal.SIGPROF ), # 27
           ( 'WINCH', signal.SIGWINCH ), # 28
           ( 'IO',    signal.SIGIO   ), # 29
           ( 'PWR',   signal.SIGPWR  ), # 30
           ( 'SYS',   signal.SIGSYS  )  # 31
]

def check_signal( sig ):
    global sigtab
    try:
        signum = int( sig )
        if signum < 0 or signum > signal.NSIG:
            return None
        for ( name, sig ) in sigtab:
            if signum == sig:
                return ( name, sig )
        return None
    except ValueError as e:
        try:
            signame = sig.upper()
            if signame[0:3] == 'SIG':
                signame = signame[3:]
            for ( name, sig ) in sigtab:
                if signame == name:
                    return ( name, sig )
            return None
        except KeyError as e:
            return None

def delimit( list, delimiter ):
    if list == [] or list == None:
        return []

    token = list.pop( 0 )
    if delimiter != None and delimiter in token:
        return token.split( delimiter ) + flatten( list, delimiter )
    return [ token ] + flatten( list, delimiter )

error = False

ps_ax        = ''
flag_bsd_u   = False
flag_root    = False
flag_task    = False
flag_family  = False
thread_mode  = False
flag_kill    = False
flag_verbose = False
flag_debug   = False
ps_opts      = None
top_opts     = None
killsig      = None

selections = []

def is_option( opt ):
    if opt == None:
        return False
    return opt[0] == '-'

def is_skip( opt ):
    if opt == None:
        return True
    return opt == '-' or opt == '--'

check_gen = os.environ.get( 'PIPS_CHECK_GEN' )
check_out = os.environ.get( 'PIPS_CHECK_OUT' )
# for checking
if check_gen != None and check_out != None:
    print_usage( '????' )
# generating test data for checking afterwords
if check_gen != None:
    check_input  = open( check_gen+'.input',  mode='w', encoding='ascii' )
    check_output = open( check_gen+'.output', mode='w', encoding='ascii' )
    print( 'simply ignore this line', file=check_input )
if check_out != None:
    check_output = open( check_out+'.check',  mode='w', encoding='ascii' )

if len(sys.argv) > 0:
    args = sys.argv
    aux = args[0]

    if aux[0] != '-':
        if 'a' in aux:
            ps_ax = ps_ax + 'a'
        if 'x' in aux:
            ps_ax = ps_ax + 'x'
        if 'u' in aux:
            flag_bsd_u = True
        if ps_ax != '' or flag_bsd_u:
            args.pop(0)

    argc = len(args)
    idx  = 0
    while idx < argc:
        opt = args[idx]
        if flag_debug:
            print( str(idx)+'/'+str(argc), opt, args )
        idx += 1
        if idx < argc:
            nxt = args[idx]
        else:
            nxt = None
        if opt == '--root' or opt == '-r':
            flag_root = True
        elif opt == '--task' or opt == '-t':
            flag_task = True
        elif opt == '--family' or opt == '-f':
            flag_family = True
        elif opt == '--kill' or opt == '-k':
            flag_kill = True
        elif opt == '--signal' or opt == '-s':
            if killsig != None:
                print_usage( 'Multiple signal options' )
            if is_skip( nxt ) or is_option( nxt ):
                print_usage( 'No signal specified' )
            killsig = check_signal( nxt )
            if killsig == None:
                print_usage( 'Invalid signal' )
            idx += 1
        elif opt == '--ps' or opt == '-P':
            if ps_opts == None:
                ps_opts = []
            if not is_skip( nxt ):
                ps_opts = ps_opts + nxt.split( ',' )
                idx += 1
        elif opt == '--top' or opt == '-T':
            if top_opts == None:
                top_opts = []
            if not is_skip( nxt ):
                top_opts = top_opts + nxt.split( ',' )
                idx += 1
        elif opt == '--verbose' or opt == '-v':
            flag_verbose = True
        elif opt == '--debug':
            flag_debug = True
        elif is_skip( opt ):
            continue
        elif opt[0] == '-':
            print_usage( 'Unknown option: ' + opt )
        else:
            selections = args[idx-1:]
            break
        continue

if flag_debug:
    print( 'Selections:', selections )

if ps_opts != None and top_opts != None:
    ex_print( '--ps and --top options are exclusive' )

if flag_kill and killsig != None:
    ex_print( '--kill and --signal options are exclusive' )
if flag_kill:
    killsig = ( 'TERM',  signal.SIGTERM )

if flag_kill and ps_opts != None:
    ex_print( '( --kill and --ps options are exclusive' )
if flag_kill and top_opts != None:
    ex_print( '( --kill and --top options are exclusive' )

if killsig != None and ps_opts != None:
    ex_print( '( --signal and --ps options are exclusive' )
if killsig != None and top_opts != None:
    ex_print( '( --signal and --top options are exclusive' )

pips_postfix = 'comm tid pid ppid'
if flag_bsd_u:
    format = 'user pid tid %cpu %mem vsz rss tty stat start_time cputime'
elif ps_ax == '':
    format = 'pid tid tty time'
else:
    format = 'pid tid tty stat time'
ps_cmd = [ 'ps', ps_ax+'H', '--format' ] + [ format + ' ' + pips_postfix ]

if flag_debug:
    print( ps_cmd, file=sys.stderr )

def get_command( psline ):
    return psline[-4]

def get_tid( psline ):
    return psline[-3]

def get_pid( psline ):
    return psline[-2]

def get_ppid( psline ):
    return psline[-1]

def format_header( header ):
    head = header[:-3]
    head.insert( -1, 'PIP' )
    return head

def format_psline( psline ):
    cmd = get_command( psline )
    first  = cmd[0]
    second = cmd[1]
    if second == ':':
        mode = 'L'
    elif second == ';':
        mode = 'C'
    elif second == '.':
        mode = 'G'
    elif second == '|':
        mode = 'T'
    else:
        mode = '?'
    line = psline[:-4]
    line += [ first+mode, cmd[2:] ]
    return line

def pip_symbol( sym ):
    if sym in ":;.|?":
        return True
    return False

def pip_root_symbol( sym ):
    if sym == 'R':
        return True
    return False

def pip_task_symbol( sym ):
    if sym in '0123456789':
        return True
    return False

def get_mode( ps ):
    cmd = get_command( ps )
    return cmd[1]

def is_threaded( mode ):
    if mode == '|':
        return True
    return False

def isa_piproot( cmd ):
    global thread_mode
    if pip_root_symbol( cmd[0] ):
        return True
    return False

def isa_piptask( cmd ):
    global thread_mode
    if pip_task_symbol( cmd[0] ):
        return True
    return False

def is_selected( ps, cmd, patterns ):
    if patterns == []:
        return True
    if len(cmd) > 2 and cmd[2:] in patterns:
        return True
    tid = get_tid( ps )
    if tid in patterns:
        return True
    pid = get_pid( ps )
    if pid in patterns:
        return True

    if flag_fnmatch:
        for pat in patterns:
            if fnm.fnmatch( cmd, pat ):
                return True
    return False

def has_pc_relation( parent, child ):
    mp = get_mode( parent )
    mc = get_mode( child  )
    if mp != mc:
        return False
    if is_threaded( mp ):
        if get_pid( parent ) == get_pid( child ):
            return True
        return False
    else:
        if get_pid( parent ) == get_ppid( child ):
            return True
        return False

os.environ['LANG'] = 'C'
piplines = []

def read_ps_output( fstream ):
    global piplines, thread_mode, header

    while True:
        ps = fstream.readline()
        if ps == '':
            break;
        if check_gen != None:
            print( ps, end='', file=check_input )

        psl = ps.split()
        if header == None:
            header = psl
        else:
            cmd = get_command( psl )
            if isa_piproot( cmd ) or isa_piptask( cmd ):
                piplines += [ psl ]
                if is_threaded( cmd[1] ):
                    thread_mode = True
        continue

header = None

if check_out == None:
    with sp.Popen( ps_cmd, stdout=sp.PIPE, encoding='ascii' ) as psproc:
        read_ps_output( psproc.stdout )
    if check_gen != None:
        check_input.close()
else:
    with open( check_out+'.input', mode='r', encoding='ascii' ) as fstream:
        fstream.readline() # skip the very first line
        read_ps_output( fstream )
#try:
#except Exception as e:
#    ex_print( 'ps command error: ' + str(e) )

patterns = []
for select in selections:
    patterns += [ select[0:14] ]

pip_roots = []
pip_tasks = []
pip_all_roots = []
pip_all_tasks = []
for ps in piplines:
    cmd = get_command( ps )
    if isa_piproot( cmd ):
        pip_all_roots += [ ps ]
        if ( not flag_root and not flag_task ) or flag_root:
            if is_selected( ps, cmd, patterns ):
                pip_roots += [ ps ]
    elif isa_piptask( cmd ):
        pip_all_tasks += [ ps ]
        if ( not flag_root and not flag_task ) or flag_task:
            if is_selected( ps, cmd, patterns ):
                pip_tasks += [ ps ]

if flag_family:
    fmly_roots = []
    fmly_tasks = []
    for rs in pip_roots:
        fmly_roots += [ rs ]
        for ts in pip_all_tasks:
            if has_pc_relation( rs, ts ):
                fmly_tasks += [ ts ]
    for ts in pip_tasks:
        for rs in pip_all_roots:
            if has_pc_relation( ts, rs ) and rs not in fmly_roots:
                fmly_roots += [ rs ]
    for rs in fmly_roots:
        for ts in pip_all_tasks:
            if has_pc_relation( rs, ts ) and ts not in fmly_tasks:
                fmly_tasks += [ ts ]
    pip_roots = fmly_roots
    pip_tasks = fmly_tasks

def sort_tid( psline ):
    return int( get_tid( psline ) )

pip_roots.sort( key=sort_tid )
pip_tasks.sort( key=sort_tid )

all_tasks = pip_roots + pip_tasks
if all_tasks == []:
    ex_print( 'no PiP task found' )
all_tasks.sort( key=sort_tid )

if flag_debug:
    for ps in all_tasks:
        print( ps )

if killsig != None:
    ( signame, signum ) = killsig
    try:
        for ps in all_tasks:
            tid = get_tid( ps )
            if flag_verbose:
                eprint( 'kill -s ' + signame + ' ' + tid )
            if check_gen == None and check_out == None:
                os.kill( int(tid), signum )
            else:
                print( 'kill', tid, signame, file=check_output )
    except Exception as e:
        error = True
        eprint( 'kill(' + signame + ',' + tid + '): ' + str(e) )

elif ps_opts != None:
    ps_cmd = 'ps'
    ps_uH = ''
    if flag_bsd_u:
        ps_uH += 'u'
    if thread_mode:
        ps_uH += 'H'
    ps_opts = [ ps_ax + ps_uH ] + ps_opts
    pid_list = []
    for ps in all_tasks:
        pid = get_pid( ps )
        if not pid in pid_list:
            pid_list += [ pid ]
    try:
        if check_gen == None and check_out == None:
            if flag_debug:
                print( ps_cmd, ps_opts, pid_list )
            os.execvp( ps_cmd, [ps_cmd] + ps_opts + pid_list )
        else:
            print( 'execvp(', ps_cmd, ' '.join(ps_opts+pid_list), ')',
                   file=check_output )
    except Exception as e:
        error = True
        eprint( 'execvp(ps):' + str(e) )

elif top_opts != None:
    top_cmd = 'top'
    if thread_mode:
        top_opts += [ '-H' ]
    pid_list = []
    for ps in all_tasks:
        pid_list += [ get_pid( ps ) ]
    pid_opt = [ '-p', ','.join( pid_list ) ]
    try:
        if check_gen == None and check_out == None:
            if flag_debug:
                print( ps_cmd, top_opts, pid_opt )
            os.execvp( top_cmd, [top_cmd] + top_opts + pid_opt )
        else:
            print( 'execvp(', top_cmd, ' '.join(top_opts+pid_opt), ')',
                   file=check_output )
    except Exception as e:
        error = True
        eprint( 'execvp(top):' + str(e) )

else:
    out_list = []
    if flag_family:
        for pr in pip_roots:
            out_list += [ pr ]
            for pt in pip_tasks:
                if has_pc_relation( pr, pt ):
                    out_list += [ pt ]
    elif not flag_root and not flag_task:
        for ps in all_tasks:
            out_list += [ ps ]
    else:
        if flag_root:
            for ps in pip_roots:
                out_list += [ ps ]
        if flag_task:
            for ps in pip_tasks:
                out_list += [ ps ]
    # format
    outl = [ format_header( header ) ]
    for out in out_list:
        outl += [ format_psline( out ) ]
    w = []
    for tkn in outl[0]:
        if tkn in wtab:
            w += [ wtab[tkn] + 1 ]
        else:
            w += [ len(tkn) + 1 ]
    for line in outl[1:]:
        idx = 0
        for tkn in line:
            wt = len( tkn ) + 1
            if wt > w[idx]:
                w[idx] = wt
            idx += 1
    # output
    for line in outl:
        idx = 0
        for tkn in line:
            print( tkn.ljust(w[idx]), end='' )
            if check_gen != None or check_out != None:
                print( tkn.ljust(w[idx]), end='', file=check_output )
            idx += 1
        print( '' )             # newline
        if check_gen != None or check_out != None:
            print( '', file=check_output )

if check_gen != None or check_out != None:
    check_output.close()

if error:
    sys.exit( 1 )
