\hypertarget{group__pip-overview}{\section{pip-\/overview}
\label{group__pip-overview}\index{pip-\/overview@{pip-\/overview}}
}


the Pi\-P library  


the Pi\-P library \hypertarget{group__pip-overview_overview}{}\subsection{Overview}\label{group__pip-overview_overview}
Pi\-P is a user-\/level library which allows a process to create sub-\/processes into the same virtual address space where the parent process runs. The parent process and sub-\/processes share the same address space, however, each process has its own static variables. So, each process runs independently from the other process. If some or all processes agreed, then data own by a process can be accessed by the other processes.

Those processes share the same address space, just like pthreads, but each process has its own variables like processes. The parent process is called {\itshape Pi\-P} {\itshape process} and sub-\/processes are called {\itshape Pi\-P} {\itshape task} since it has the best of the both worlds of processes and pthreads.

Pi\-P root can spawn one or more number of Pi\-P tasks. The executable of the Pi\-P task must be compiled (with the \char`\"{}-\/fpie\char`\"{} or \char`\"{}-\/pic\char`\"{} compile option) and linked (with the \char`\"{}-\/pie\char`\"{} linker option) to be a P\-I\-E (Position Independent Executable).

When a Pi\-P root or Pi\-P task is willing to be accessed the its own data by the other(s), firstly a memory region where the data to be accessed are located must be {\itshape exported}. Then the exported memory region is {\itshape imported} so that the exported and imported data can be accessed. The Pi\-P library supports the functions to export and import the pointers to memory regions.

Unlike shared memory techniques (shared mmap, P\-O\-S\-I\-X-\/shmem, S\-Y\-S\-V-\/shmem, and X\-P\-M\-E\-M), Pi\-P allows Pi\-P root and Pi\-P tasks share the entire virtual address space fromm the beginning. So, any pointers can be dereferenced as they are. Additionally there is no need to cast a spell to share a memory region. All users have to do is passing pointers.\hypertarget{group__pip-overview_Bi-Level}{}\subsection{Thread}\label{group__pip-overview_Bi-Level}
\hypertarget{group__pip-overview_Bi-Level}{}\subsubsection{Thread}\label{group__pip-overview_Bi-Level}
Pi\-P also provides new thread implementation named \char`\"{}\-Bi-\/\-Level Thread
(\-B\-L\-T)\char`\"{}, again, to take the best of two worlds, Kernel-\/\-Level Thread (K\-L\-T) and User-\/\-Level Thread (U\-L\-T) here. A B\-L\-T is a Pi\-P task. When a Pi\-P task is created it runs as a K\-L\-T. At any point the K\-L\-T can becomme a U\-L\-T by decoupling the associated kernel thread from the K\-L\-T. The decoupled kernel thread becommes idle. Later, the U\-L\-T can become K\-L\-T again by coupling with the kernel thread.\hypertarget{group__pip-overview_User-Level}{}\subsubsection{Process}\label{group__pip-overview_User-Level}
As described, Pi\-P allows Pi\-P tasks to share the same virtual address space. This mans that a Pi\-P task can context-\/switch to the other Pi\-P task at user-\/level. This is called User-\/\-Level Process where processes may be derived from the same program or different programs. Threads basically share most of the kernel resources, such as address space, file descriptors, a process id, and so on whilst processes do not. Every process has its ows file descriptor space, for example. When a U\-L\-P is scheduled by a K\-L\-T having P\-I\-D 1000, then the {\bfseries getpid()} {\bfseries is} called by the U\-L\-P returns 1000. Further, when the U\-L\-T is migrated to be scheduled by the other K\-L\-T, then the returned P\-I\-D is different. So, when implemnting a U\-L\-P system, this systemcall consistency must be preserved. In U\-L\-P on Pi\-P, the consistency can be maintained by utilizing the above B\-L\-T mechanism. When a U\-L\-T tries to call a system call, it is coupled with its kernel thread which was created at the beginning as a K\-L\-T.\hypertarget{group__pip-overview_execution-mode}{}\subsection{Execution mode}\label{group__pip-overview_execution-mode}
There are several Pi\-P implementation modes which can be selected at the runtime. These implementations can be categorized into two according to the behavior of Pi\-P tasks,


\begin{DoxyItemize}
\item {\ttfamily Pthread}, and
\item {\ttfamily Process}.
\end{DoxyItemize}

In the pthread mode, although each Pi\-P task has its own variables unlike thread, Pi\-P task behaves more like Pthread, having a T\-I\-D, having the same file descriptor space, having the same signal delivery semantics as Pthread does, and so on. In the process mode, Pi\-P task behaves more like a process, having a P\-I\-D, having an independent file descriptor space, having the same signal delivery semantics as Linux process does, and so on. The above mentioned U\-L\-P can only work with the process mode.

When the {\ttfamily P\-I\-P\-\_\-\-M\-O\-D\-E} environment variable set to "thread" then the Pi\-P library runs based on the pthread mode, and it is set to "process" then it runs with the process mode. There are also two implementations in the {\bfseries process} mode; "process\-:preload" and "process\-:pipclone" The former one must be with the {\bfseries L\-D\-\_\-\-P\-R\-E\-L\-O\-A\-D} environment variable setting so that the {\bfseries clone()} system call wrapper can work with. The latter one can only be specified with the P\-I\-P-\/patched glibc library (see below\-: {\bfseries G\-L\-I\-B\-C} issues).

There several function provided by the Pi\-P library to absorb the difference due to the execution mode\hypertarget{group__pip-overview_limitation}{}\subsection{Limitation}\label{group__pip-overview_limitation}
Pi\-P allows Pi\-P root and Pi\-P tasks to share the data, so the function pointer can be passed to the others. However, jumping into the code owned by the other may not work properly for some reasons.\hypertarget{group__pip-overview_compile-and-link}{}\subsection{Compile and Link User programs}\label{group__pip-overview_compile-and-link}
The Pi\-P root ust be linked with the Pi\-P library and libpthread. The programs able to run as a Pi\-P task must be compiled with the "-\/fpie" compile option and the "-\/pie -\/rdynamic" linker options.\hypertarget{group__pip-overview_glibc-issues}{}\subsection{G\-L\-I\-B\-C issues}\label{group__pip-overview_glibc-issues}
The Pi\-P library is implemented at the user-\/level, i.\-e. no need of kernel patches nor kernel modules. Due to the novel usage of combining {\ttfamily dlmopn()} G\-L\-I\-B\-C function and {\ttfamily clone()} systemcall, there are some issues found in the G\-L\-I\-B\-C. To avoid this issues, Pi\-P users are recommenmded to have the patched G\-L\-I\-B\-C provided by the Pi\-P development team.\hypertarget{group__pip-overview_PiP-GDB}{}\subsection{Pi\-P-\/\-G\-D\-B}\label{group__pip-overview_PiP-GDB}
The normal gdb debugger only works with the Pi\-P root. Pi\-P-\/aware G\-D\-B (Pi\-P-\/gdb) is also provided and must be used for debugging Pi\-P tasks. In Pi\-P-\/gdb, Pi\-P tasks and root can be debugged as G\-D\-B inferiors. The current Pi\-P-\/gdb does not work with the Pi\-P's thread execution mode.\hypertarget{group__pip-overview_debug}{}\subsection{Debug on Exception Signals}\label{group__pip-overview_debug}
If the P\-I\-P\-\_\-\-G\-D\-B\-\_\-\-P\-A\-T\-H environment is set to the path to Pi\-P-\/gdb, then Pi\-P-\/gdb is automatically attached when an excetion signal (S\-I\-G\-S\-E\-G\-V and S\-I\-G\-H\-U\-P by default) is delivered. The exception signals can also be defined by setting the P\-I\-P\-\_\-\-G\-D\-B\-\_\-\-S\-I\-G\-N\-A\-L\-S environment. Signal names can be concatenated by the '+' or '-\/' symbol. 'all' is reserved to specify most of the signals. For example, 'A\-L\-L-\/\-T\-E\-R\-M' means all signals excepting S\-I\-G\-T\-E\-R\-M, another example, 'P\-I\-P\-E+\-I\-N\-T' means S\-I\-G\-P\-I\-P\-E and S\-I\-G\-I\-N\-T. If one of the defined or default signals is delivered, then Pi\-P-\/gdb will be attached. The Pi\-P-\/gdb will show backtrace by default. If users specify P\-I\-P\-\_\-\-G\-D\-B\-\_\-\-C\-O\-M\-M\-A\-N\-D that contains G\-D\-B commands, then those G\-D\-B commands will be executed by the G\-D\-B in batch mode.

\begin{DoxySeeAlso}{See Also}
\hyperlink{group__pipcc}{pipcc}
\end{DoxySeeAlso}
\hypertarget{group__pip-overview_author}{}\subsection{Author}\label{group__pip-overview_author}
Atsushi Hori (R\-I\-K\-E\-N, Japan) \href{mailto:ahori@riken.jp}{\tt ahori@riken.\-jp} 