<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>PiP - Process-in-Process: (This is a Doxygen directive and just ignore)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PiP - Process-in-Process
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">(This is a Doxygen directive and just ignore) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>Process-in-Process (PiP)</h1>
<h1>Description</h1>
<p>PiP is a user-level library to have the best of the both worlds of multi-process and multi-thread parallel execution models. PiP allows a process to create sub-processes into the same virtual address space where the parent process runs. The parent process and sub-processes share the same address space, however, each process has its own variable set. So, each process runs independently from the other process. If some or all processes agree, then data own by a process can be accessed by the other processes. Those processes share the same address space, just like pthreads, and each process has its own variables like a process. The parent process is called PiP process and a sub-process are called a PiP task.</p>
<h2>PiP Versions</h2>
<p>Currently there are three PiP library versions:</p>
<ul>
<li>Version 1 - Deprecated</li>
<li>Version 2 - Stable version</li>
<li>Version 3 - Stable version supporting BLT and ULP</li>
</ul>
<p>In this document, <b>N</b> denotes the PiP version number.</p>
<h2>Bi-Level Thread (BLT, from v3)</h2>
<p>PiP also provides new thread implementation named "Bi-Level Thread
(BLT)", again, to take the best of two worlds, Kernel-Level Thread (KLT) and User-Level Thread (ULT) here. A BLT is a PiP task. When a PiP task is created it runs as a KLT. At any point the KLT can becomme a ULT by decoupling the associated kernel thread from the KLT. The decoupled kernel thread becommes idle. Later, the ULT can become KLT again by coupling with the kernel thread.</p>
<h2>User-Level Process (ULP, from v3)</h2>
<p>As described, PiP allows PiP tasks to share the same virtual address space. This mans that a PiP task can context-switch to the other PiP task at user-level. This is called User-Level Process where processes may be derived from the same program or different programs. Threads basically share most of the kernel resources, such as address space, file descriptors, a process id, and so on whilst processes do not. Every process has its ows file descriptor space, for example. When a ULP is scheduled by a KLT having PID 1000, then the getpid() is called by the ULP returns 1000. Further, when the ULT is migrated to be scheduled by the other KLT, then the returned PID is different. So, when implemnting a ULP system, this systemcall consistency must be preserved. In ULP on PiP, the consistency can be maintained by utilizing the above BLT mechanism. When a ULT tries to call a system call, it is coupled with its kernel thread which was created at the beginning as a KLT. It should be note that Thread Local Storage (TLS) regions are also switched when switching ULP (and BLT) contexts.</p>
<h2>Execution Mode</h2>
<p>There are several PiP implementation modes which can be selected at the runtime. These implementations can be categorized into two according to the behavior of PiP tasks,</p>
<ul>
<li>Process and</li>
<li>(P)Thread</li>
</ul>
<p>In the pthread mode, although each PiP task has its own variables unlike thread, PiP task behaves more like PThread, having a TID, having the same file descriptor space, having the same signal delivery semantics as Pthread does, and so on. In the process mode, PiP task behaves more like a process, having a PID, having an independent file descriptor space, having the same signal delivery semantics as Linux process does, and so on. The above mentioned ULP can only work with the process mode.</p>
<p>When the <code>PIP_MODE</code> environment variable set to "thread" or "pthread" then the PiP library runs based on the pthread mode, and it is set to "process" then it runs with the process mode. There are also three implementations in the process mode; "process:preload," "process:pipclone" and "process:got." The "process:preload" mode must be with the LD_PRELOAD environment variable setting so that the clone() system call wrapper can work with. The "process:pipclone" mode can only be specified with the PIP-patched glibc library (see below: GLIBC issues).</p>
<p>There several function provided by the PiP library to absorb the difference due to the execution mode</p>
<h1>License</h1>
<p>This project is licensed under the 2-clause simplified BSD License - see the [LICENSE](LICENSE) file for details.</p>
<h1>Installation</h1>
<h2>PiP Trial by using Docker image</h2>
<p>Download and run the PiP Docker image. </p>
<pre class="fragment">$ docker pull rikenpip/pip-vN
$ sudo docker run -it rikenpip/pip-vN /bin/bash
</pre><h2>Source Repositories</h2>
<p>The installation of PiP related packages must follow the order below;</p>
<ol type="1">
<li>Build PiP-glibc (optional)</li>
<li>Build PiP</li>
<li>Build PiP-gdb (optional)</li>
</ol>
<p>Note that if PiP-gdb will not work at all without PiP-glibc. Further, PiP can only create up to around ten PiP tasks without installing PiP-glibc.</p>
<ul>
<li><a href="https://github.com/RIKEN-SysSoft/PiP-glibc">PiP-glibc</a> - patched GNU libc for PiP</li>
<li><a href="https://github.com/RIKEN-SysSoft/PiP">PiP</a> - Process in Process (this package)</li>
<li><a href="https://github.com/RIKEN-SysSoft/PiP-gdb">PiP-gdb</a> - patched gdb to debug PiP root and PiP tasks.</li>
</ul>
<p>Before installing PiP, we strongly recommend you to install PiP-glibc.</p>
<p>After installing PiP, PiP-gdb can be installed too.</p>
<h2>Installation from the source code.</h2>
<ol type="1">
<li><p class="startli">Building PiP-glibc (optional)</p>
<p class="startli">Fetch source tree (CentOS7 or RHEL7):</p>
<p class="startli">$ git clone -b pip-centos7 <a href="#" onclick="location.href='mai'+'lto:'+'git'+'@g'+'it.'+'sy'+'s.a'+'ic'+'s.r'+'ik'+'en.'+'jp'; return false;">git@g<span style="display: none;">.nosp@m.</span>it.s<span style="display: none;">.nosp@m.</span>ys.ai<span style="display: none;">.nosp@m.</span>cs.r<span style="display: none;">.nosp@m.</span>iken.<span style="display: none;">.nosp@m.</span>jp</a>:software/PIP-glibc</p>
<p class="startli">Fetch source tree (CentOS8 or RHEL8):</p>
<p class="startli">$ git clone -b pip-centos8 <a href="#" onclick="location.href='mai'+'lto:'+'git'+'@g'+'it.'+'sy'+'s.a'+'ic'+'s.r'+'ik'+'en.'+'jp'; return false;">git@g<span style="display: none;">.nosp@m.</span>it.s<span style="display: none;">.nosp@m.</span>ys.ai<span style="display: none;">.nosp@m.</span>cs.r<span style="display: none;">.nosp@m.</span>iken.<span style="display: none;">.nosp@m.</span>jp</a>:software/PIP-glibc</p>
<p class="startli">Build PiP-glibc</p>
<p class="startli">$ mkdir GLIBC_BUILD_DIR $ cd GLIBC_BUILD_DIR $ GLIBC_SRC_DIR/build.sh &ndash;prefix=GLIBC_INSTALL_DIR</p>
</li>
<li><p class="startli">Build PiP library</p>
<p class="startli">The same source code can be ussed for CentOS7 and CentOS8 (RHEL7 and RHEL8).</p>
<p class="startli">$ git clone -b pip-N <a href="#" onclick="location.href='mai'+'lto:'+'git'+'@g'+'it.'+'sy'+'s.a'+'ic'+'s.r'+'ik'+'en.'+'jp'; return false;">git@g<span style="display: none;">.nosp@m.</span>it.s<span style="display: none;">.nosp@m.</span>ys.ai<span style="display: none;">.nosp@m.</span>cs.r<span style="display: none;">.nosp@m.</span>iken.<span style="display: none;">.nosp@m.</span>jp</a>:software/PiP $ cd PIP_SRC_DIR $ ./configure &ndash;prefix=PIP_INSTALL_DIR [ &ndash;with-glibc-libdir=GLIBC_INSTALL_DIR/lib ] $ make install doxgyen-install $ cd PIP_INSTALL_DIR/bin $ ./piplnlibs</p>
<p class="startli">If you want to make sure if the PiP library is correctly installed, then do the following;</p>
<p class="startli">$ cd PIP_SRC_DIR $ make install-test</p>
<p class="startli">Important note: The prefix directory of PiP-glibc and the prefix directory of PiP itself must NOT be the same.</p>
</li>
<li><p class="startli">Build PiP-gdb (optional)</p>
<p class="startli">Fetch source tree (CentOS7 or RHEL7):</p>
<p class="startli">$ git clone -b pip-centos7 <a href="#" onclick="location.href='mai'+'lto:'+'git'+'@g'+'it.'+'sy'+'s.a'+'ic'+'s.r'+'ik'+'en.'+'jp'; return false;">git@g<span style="display: none;">.nosp@m.</span>it.s<span style="display: none;">.nosp@m.</span>ys.ai<span style="display: none;">.nosp@m.</span>cs.r<span style="display: none;">.nosp@m.</span>iken.<span style="display: none;">.nosp@m.</span>jp</a>:software/PIP-gdb</p>
<p class="startli">Ftech source tree (CentOS8 or RHEL8):</p>
<p class="startli">$ git clone -b pip-centos8 <a href="#" onclick="location.href='mai'+'lto:'+'git'+'@g'+'it.'+'sy'+'s.a'+'ic'+'s.r'+'ik'+'en.'+'jp'; return false;">git@g<span style="display: none;">.nosp@m.</span>it.s<span style="display: none;">.nosp@m.</span>ys.ai<span style="display: none;">.nosp@m.</span>cs.r<span style="display: none;">.nosp@m.</span>iken.<span style="display: none;">.nosp@m.</span>jp</a>:software/PIP-gdb</p>
<p class="startli">Build PiP-gdb</p>
<p class="startli">$ cd GLIBC_SRC_DIR $ ./build.sh &ndash;prefix=GLIBC_INSTALL_DIR &ndash;with-pip=PIP_INSTALL_DIR</p>
<p class="startli">The prefix directory of PiP-gdb can be the same with the prefix directory of PiP library.</p>
</li>
</ol>
<h2>Installation from RPMs</h2>
<p>RPM packages and their yum repository are also available for CentOS 7 / RHEL7. </p>
<pre class="fragment">$ sudo rpm -Uvh https://git.sys.r-ccs.riken.jp/PiP/package/el/7/noarch/pip-1/pip-release-N-0.noarch.rpm
$ sudo yum install pip-glibc
$ sudo yum install pip pip-debuginfo
$ sudo yum install pip-gdb
</pre><p>If PiP packages are installed by the above RPMs, <b>PIP_INSTALL_DIR</b> is "/usr."</p>
<h1>PiP documents</h1>
<p>The following PiP documents are created by using <a href="https://www.doxygen.nl/">Doxygen</a>.</p>
<h2>Man pages</h2>
<p>Man pages will be installed at <b>PIP_INSTALL_DIR</b>/share/man. </p>
<pre class="fragment">$ man -M PIP_INSTALL_DIR/share/man 7 libpip
</pre><p>Or, use the pip-man command (fromm v2). </p>
<pre class="fragment">$ PIP_INSTALL_DIR/bin/pip-man 7 libpip
</pre><p>The above two exammples will show you the same document you are reading.</p>
<h2>HTML</h2>
<p>HTML documents will be installed at <b>PIP_INSTALL_DIR</b>/share/doc/pip.</p>
<h1>Getting Started</h1>
<h2>To compile and link your PiP programs</h2>
<ul>
<li>pipcc(1) command (since v2)</li>
</ul>
<p>You can use pipcc(1) command to compile and link your PiP programs. </p>
<pre class="fragment">$ pipcc -Wall -O2 -g -c pipmodule.c
$ pipcc -Wall -O2 -g -o pipprog pipprog.c
</pre><h2>To run your PiP programs</h2>
<ul>
<li>pip-exec(1) command (in v1, piprun)</li>
</ul>
<p>Let's assume your that have a non-PiP program(s) and wnat to run as PiP tasks. All you have to do is to compile your program by using the above pipcc(1) command and to use the pip-exec(1) command to run your program as PiP tasks. </p>
<pre class="fragment">$ pipcc myprog.c -o myprog
$ pip-exec -n 8 ./myprog
$ ./myprog
</pre><p>In this case, the pip-exec(1) command becomes the PiP root and your program runs as 8 PiP tasks. Your program can also run as a normal (non-PiP) program without using the pip-exec(1) command. Note that the 'myprog.c' may or may not call any PiP functions.</p>
<p>You may write your own PiP programs whcih includes the PiP root programming. In this case, your program can run without using the pip-exec(1) command.</p>
<p>If you get the following message when you try to run your program; </p>
<pre class="fragment">PiP-ERR(19673) './myprog' is not PIE
</pre><p>Then this means that the 'myprog' is not compiled by using the pipcc(1) command properly. You may check if your program(s) can run as a PiP root and/or PiP task by using the pip-check(1) command (fromm v2); </p>
<pre class="fragment">$ pip-check a.out
a.out : Root&amp;Task
</pre><p>Above example shows that the 'a.out' program can run as a PiP root and PiP tasks.</p>
<ul>
<li><p class="startli">pips(1) command (fromm v2)</p>
<p class="startli">You can check if your PiP program is running or not by using the pips(1) command.</p>
</li>
</ul>
<p>List the PiP tasks via the 'ps' command; </p>
<pre class="fragment">$ pips -l [ COMMAND ]
</pre><p>or, show the activities of PiP tasks via the 'top' command; </p>
<pre class="fragment">$ pips -t [ COMMAND ]
</pre><p>Here <b>COMMAND</b> is the name (not a path) of PiP program you are running.</p>
<p>Additionally you can kill all of your PiP tasks by using the same pips(1) command; </p>
<pre class="fragment">$ pips -s KILL [ COMMAND ]
</pre><h2>Debugging your PiP programs by the pip-gdb command</h2>
<p>The following procedure attaches all PiP tasks, which are created by same PiP root task, as GDB inferiors. </p>
<pre class="fragment">$ pip-gdb
(gdb) attach PID
</pre><p>The attached inferiors can be seen by the following GDB command: </p>
<pre class="fragment">(gdb) info inferiors
  Num  Description              Executable
  4    process 6453 (pip 2)     /somewhere/pip-task-2
  3    process 6452 (pip 1)     /somewhere/pip-task-1
  2    process 6451 (pip 0)     /somewhere/pip-task-0
* 1    process 6450 (pip root)  /somewhere/pip-root
</pre><p>You can select and debug an inferior by the following GDB command: </p>
<pre class="fragment">(gdb) inferior 2
[Switching to inferior 2 [process 6451 (pip 0)] (/somewhere/pip-task-0)]
</pre><p>When an already-attached program calls 'pip_spawn()' and becomes a PiP root task, the newly created PiP child tasks aren't attached automatically, but you can add empty inferiors and then attach the PiP child tasks to the inferiors. e.g. </p>
<pre class="fragment">.... type Control-Z to stop the root task.
^Z
Program received signal SIGTSTP, Stopped (user).

(gdb) add-inferior
Added inferior 2
(gdb) inferior 2
(gdb) attach 1902

(gdb) add-inferior
Added inferior 3
(gdb) inferior 3
(gdb) attach 1903

(gdb) add-inferior
Added inferior 4
(gdb) inferior 4
(gdb) attach 1904

(gdb) info inferiors
  Num  Description              Executable
* 4    process 1904 (pip 2)     /somewhere/pip-task-2
  3    process 1903 (pip 1)     /somewhere/pip-task-1
  2    process 1902 (pip 0)     /somewhere/pip-task-0
  1    process 1897 (pip root)  /somewhere/pip-root
</pre><p>You can attach all relevant PiP tasks by: </p>
<pre class="fragment">$ pip-gdb -p PID-of-your-PiP-program
</pre><p>(from v2)</p>
<p>If the PIP_GDB_PATH environment is set to the path pointing to PiP-gdb executable file, then PiP-gdb is automatically attached when an excetion signal (SIGSEGV and SIGHUP by default) is delivered. The exception signals can also be defined by setting the PIP_GDB_SIGNALS environment. Signal names (case insensitive) can be concatenated by the '+' or '-' symbol. 'all' is reserved to specify most of the signals. For example, 'ALL-TERM' means all signals excepting SIGTERM, another example, 'PIPE+INT' means SIGPIPE and SIGINT. If one of the defined or default signals is delivered, then PiP-gdb will be attached. The PiP-gdb will show backtrace by default. If users specify PIP_GDB_COMMAND that a filename containing some GDB commands, then those GDB commands will be executed by the GDB, instead of backtrace, in batch mode. If the PIP_STOP_ON_START environment is set (to any value), then the PiP library delivers SIGSTOP to a spawned PiP task which is about to start user program.</p>
<h1>FAQ</h1>
<ul>
<li>Does MPI with PiP exist? Currently, we are working with ANL to develop MPICH using PiP. This repository, located at ANL, is not yet open to public at the time of this writing.</li>
</ul>
<h1>Publications</h1>
<h2>Research papers</h2>
<p>A. Hori, M. Si, B. Gerofi, M. Takagi, J. Dayal, P. Balaji, and Y. Ishikawa. "Process-in-process: techniques for practical address-space sharing," In Proceedings of the 27th International Symposium on High-Performance Parallel and Distributed Computing (HPDC '18). ACM, New York, NY, USA, 131-143. DOI: <a href="https://doi.org/10.1145/3208040.3208045">https://doi.org/10.1145/3208040.3208045</a></p>
<h2>Presentation Slides</h2>
<ul>
<li><a href="presentation/HPDC18-PiP.key.pdf">HPDC'18</a></li>
<li><a href="presentation/Ross-2018-PiP.key.pdf">ROSS'18</a></li>
<li><a href="presentation/IPDPS20-RADRws.key.pdf">IPDPS/RADR'20</a></li>
</ul>
<h1>Query</h1>
<p>Send e-mails to <a href="#" onclick="location.href='mai'+'lto:'+'pip'+'@m'+'l.r'+'ik'+'en.'+'jp'; return false;">pip@m<span style="display: none;">.nosp@m.</span>l.ri<span style="display: none;">.nosp@m.</span>ken.j<span style="display: none;">.nosp@m.</span>p</a></p>
<h1>Author</h1>
<p>Atsushi Hori Riken Center for Commputational Science (R-CCS) Japan </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
