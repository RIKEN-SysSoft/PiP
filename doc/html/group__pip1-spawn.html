<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Process-in-Process: Spawning PiP task</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Process-in-Process
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Spawning PiP task</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0b1e746befd27c418355d28a830b2db6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pip1-spawn.html#ga0b1e746befd27c418355d28a830b2db6">pip_spawn_from_main</a> (pip_spawn_program_t *progp, char *prog, char **argv, char **envv, void *exp)</td></tr>
<tr class="memdesc:ga0b1e746befd27c418355d28a830b2db6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting information to invoke a PiP task starting from the main function.  <a href="#ga0b1e746befd27c418355d28a830b2db6">More...</a><br/></td></tr>
<tr class="separator:ga0b1e746befd27c418355d28a830b2db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ebadd5070ca345daf8d7465f4926fc0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pip1-spawn.html#ga6ebadd5070ca345daf8d7465f4926fc0">pip_spawn_from_func</a> (pip_spawn_program_t *progp, char *prog, char *funcname, void *arg, char **envv, void *exp)</td></tr>
<tr class="memdesc:ga6ebadd5070ca345daf8d7465f4926fc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting information to invoke a PiP task starting from a function defined in a program.  <a href="#ga6ebadd5070ca345daf8d7465f4926fc0">More...</a><br/></td></tr>
<tr class="separator:ga6ebadd5070ca345daf8d7465f4926fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c3f1d9e029f68dbcfb7d78b7dfa1533"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pip1-spawn.html#ga1c3f1d9e029f68dbcfb7d78b7dfa1533">pip_spawn_hook</a> (pip_spawn_hook_t *hook, pip_spawnhook_t before, pip_spawnhook_t after, void *hookarg)</td></tr>
<tr class="memdesc:ga1c3f1d9e029f68dbcfb7d78b7dfa1533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting invocation hook information.  <a href="#ga1c3f1d9e029f68dbcfb7d78b7dfa1533">More...</a><br/></td></tr>
<tr class="separator:ga1c3f1d9e029f68dbcfb7d78b7dfa1533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1fcc4cb85ec3eda734afe2beb0c6a36"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pip1-spawn.html#gaf1fcc4cb85ec3eda734afe2beb0c6a36">pip_task_spawn</a> (pip_spawn_program_t *progp, uint32_t coreno, uint32_t opts, int *pipidp, pip_spawn_hook_t *hookp)</td></tr>
<tr class="memdesc:gaf1fcc4cb85ec3eda734afe2beb0c6a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawning a PiP task.  <a href="#gaf1fcc4cb85ec3eda734afe2beb0c6a36">More...</a><br/></td></tr>
<tr class="separator:gaf1fcc4cb85ec3eda734afe2beb0c6a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4698d85283b03f0443fb0991e1119d35"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pip1-spawn.html#ga4698d85283b03f0443fb0991e1119d35">pip_spawn</a> (char *filename, char **argv, char **envv, uint32_t coreno, int *pipidp, pip_spawnhook_t before, pip_spawnhook_t after, void *hookarg)</td></tr>
<tr class="memdesc:ga4698d85283b03f0443fb0991e1119d35"><td class="mdescLeft">&#160;</td><td class="mdescRight">spawn a PiP task (PiP v1 API and deprecated)  <a href="#ga4698d85283b03f0443fb0991e1119d35">More...</a><br/></td></tr>
<tr class="separator:ga4698d85283b03f0443fb0991e1119d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b31bc23b6e165ae50d3bdea655539c5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pip1-spawn.html#ga8b31bc23b6e165ae50d3bdea655539c5">pip_blt_spawn</a> (pip_spawn_program_t *progp, uint32_t coreno, uint32_t opts, int *pipidp, pip_task_t **bltp, pip_task_queue_t *queue, pip_spawn_hook_t *hookp)</td></tr>
<tr class="memdesc:ga8b31bc23b6e165ae50d3bdea655539c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">spawn a PiP BLT/ULP (Bi-Level Task / User-Level Process)  <a href="#ga8b31bc23b6e165ae50d3bdea655539c5">More...</a><br/></td></tr>
<tr class="separator:ga8b31bc23b6e165ae50d3bdea655539c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>


<h3><a class="anchor" id="pip-spawn"></a>PiP Spawnig PiP (ULP/BLT) task</h3><div class="textblock"><dl class="section user"><dt>Description</dt><dd>Spawning PiP task or ULP/BLT task </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga0b1e746befd27c418355d28a830b2db6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pip_spawn_from_main </td>
          <td>(</td>
          <td class="paramtype">pip_spawn_program_t *&#160;</td>
          <td class="paramname"><em>progp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>envv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>exp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>Name</dt><dd>pip_spawn_from_main<a name="ga0b1e746befd27c418355d28a830b2db6_pip_spawn_from_main"></a></dd></dl>
<dl class="section user"><dt>Synopsis</dt><dd>#include &lt;<a class="el" href="pip_8h_source.html">pip.h</a>&gt; <br/>
void pip_spawn_from_main( pip_spawn_program_t *progp, char *prog, char **argv, char **envv, void *exp )</dd></dl>
<dl class="section user"><dt>Description</dt><dd>This function sets up the <code>pip_spawn_program_t</code> structure for spawning a PiP task, starting from the mmain function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">progp</td><td>Pointer to the <code>pip_spawn_program_t</code> structure in which the program invokation information will be set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prog</td><td>Path to the executiable file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argv</td><td>Argument vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">envv</td><td>Environment variables. If this is <code>NULL</code>, then the <code>environ</code> variable is used for the spawning PiP task. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exp</td><td>Export value to the spawning PiP task</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>pip_task_spawn(3), pip_spawn_from_func(3) </dd></dl>

</div>
</div>
<a class="anchor" id="ga6ebadd5070ca345daf8d7465f4926fc0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pip_spawn_from_func </td>
          <td>(</td>
          <td class="paramtype">pip_spawn_program_t *&#160;</td>
          <td class="paramname"><em>progp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>funcname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>envv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>exp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>Name</dt><dd>pip_spawn_from_func<a name="ga6ebadd5070ca345daf8d7465f4926fc0_pip_spawn_from_func"></a></dd></dl>
<dl class="section user"><dt>Synopsis</dt><dd>#include &lt;<a class="el" href="pip_8h_source.html">pip.h</a>&gt; <br/>
pip_spawn_from_func( pip_spawn_program_t *progp, char *prog, char *funcname, void *arg, char **envv, void *exp );</dd></dl>
<dl class="section user"><dt>Description</dt><dd>This function sets the required information to invoke a program, starting from the <code>main()</code> function. The function should have the function prototype as shown below; <div class="fragment"><div class="line"><span class="keywordtype">int</span> start_func( <span class="keywordtype">void</span> *arg )</div>
</div><!-- fragment --> This start function must be globally defined in the program.. The returned integer of the start function will be treated in the same way as the <code>main</code> function. This implies that the <code>pip_wait</code> function family called from the PiP root can retrieve the return code.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">progp</td><td>Pointer to the <code>pip_spawn_program_t</code> structure in which the program invokation information will be set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prog</td><td>Path to the executiable file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">funcname</td><td>Function name to be started </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>Argument which will be passed to the start function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">envv</td><td>Environment variables. If this is <code>NULL</code>, then the <code>environ</code> variable is used for the spawning PiP task. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exp</td><td>Export value to the spawning PiP task</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>pip_task_spawn(3), pip_spawn_from_main(3) </dd></dl>

</div>
</div>
<a class="anchor" id="ga1c3f1d9e029f68dbcfb7d78b7dfa1533"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pip_spawn_hook </td>
          <td>(</td>
          <td class="paramtype">pip_spawn_hook_t *&#160;</td>
          <td class="paramname"><em>hook</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pip_spawnhook_t&#160;</td>
          <td class="paramname"><em>before</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pip_spawnhook_t&#160;</td>
          <td class="paramname"><em>after</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>hookarg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>Name</dt><dd>pip_spawn_hook<a name="ga1c3f1d9e029f68dbcfb7d78b7dfa1533_pip_spawn_hook"></a></dd></dl>
<dl class="section user"><dt>Synopsis</dt><dd>#include &lt;<a class="el" href="pip_8h_source.html">pip.h</a>&gt; <br/>
void pip_spawn_hook( pip_spawn_hook_t *hook, pip_spawnhook_t before, pip_spawnhook_t after, void *hookarg );</dd></dl>
<dl class="section user"><dt>Description</dt><dd></dd></dl>
<p>The <em>before</em> and <em>after</em> functions are introduced to follow the programming model of the <code>fork</code> and <code>exec</code>. <em>before</em> function does the prologue found between the <code>fork</code> and <code>exec</code>. <em>after</em> function is to free the argument if it is <code>malloc()ed</code>, for example. </p>
<dl class="section pre"><dt>Precondition</dt><dd>It should be noted that the <em>before</em> and <em>after</em> functions are called in the <em>context</em> of PiP root, although they are running as a part of PiP task (i.e., having PID of the spawning PiP task). Conversely speaking, those functions cannot access the variables defined in the spawning PiP task. </dd>
<dd>
The before and after hook functions should have the function prototype as shown below; <div class="fragment"><div class="line"><span class="keywordtype">int</span> hook_func( <span class="keywordtype">void</span> *hookarg )</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">hook</td><td>Pointer to the <code>pip_spawn_hook_t</code> structure in which the invocation hook information will be set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">before</td><td>Just before the executing of the spawned PiP task, this function is called so that file descriptors inherited from the PiP root, for example, can deal with. This is only effective with the PiP process mode. This function is called with the argument <em>hookarg</em> described below. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">after</td><td>This function is called when the PiP task terminates for the cleanup purpose. This function is called with the argument <em>hookarg</em> described below. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hookarg</td><td>The argument for the <em>before</em> and <em>after</em> function call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Note that the file descriptors and signal handlers are shared between PiP root and PiP tasks in the pthread execution mode.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>pip_task_spawn(3) </dd></dl>

</div>
</div>
<a class="anchor" id="gaf1fcc4cb85ec3eda734afe2beb0c6a36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pip_task_spawn </td>
          <td>(</td>
          <td class="paramtype">pip_spawn_program_t *&#160;</td>
          <td class="paramname"><em>progp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>coreno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pipidp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pip_spawn_hook_t *&#160;</td>
          <td class="paramname"><em>hookp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>Name</dt><dd>pip_task_spawn<a name="gaf1fcc4cb85ec3eda734afe2beb0c6a36_pip_task_spawn"></a></dd></dl>
<dl class="section user"><dt>Synopsis</dt><dd>#include &lt;<a class="el" href="pip_8h_source.html">pip.h</a>&gt; <br/>
int pip_task_spawn( pip_spawn_program_t *progp, uint32_t coreno, uint32_t opts, int *pipidp, pip_spawn_hook_t *hookp );</dd></dl>
<dl class="section user"><dt>Description</dt><dd>This function spawns a PiP task specified by <code>progp</code>. </dd></dl>
<dl class="section user"><dt></dt><dd>In the process execution mode, the file descriptors having the <code>FD_CLOEXEC</code> flag is closed and will not be passed to the spawned PiP task. This simulated close-on-exec will not take place in the pthread execution mode.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">progp</td><td><b>pip_spawn_program_t</b> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coreno</td><td>CPU core number for the PiP task to be bound to. By default, <code>coreno</code> is set to zero, for example, then the calling task will be bound to the 'first' core available. This is in mind that the available core numbers are not contiguous. To specify an absolute core number, <code>coreno</code> must be bitwise-ORed with <code>PIP_CPUCORE_ABS</code>. If <code>PIP_CPUCORE_ASIS</code> is specified, then the core binding will not take place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opts</td><td>option flags </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pipidp</td><td>Specify PiP ID of the spawned PiP task. If <code>PIP_PIPID_ANY</code> is specified, then the PiP ID of the spawned PiP task is up to the PiP library and the assigned PiP ID will be returned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hookp</td><td>Hook information to be invoked before and after the program invokation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned if this function succeeds. On error, an error number is returned. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EPERM</td><td>PiP library is not yet initialized </td></tr>
    <tr><td class="paramname">EPERM</td><td>PiP task tries to spawn child task </td></tr>
    <tr><td class="paramname">EINVAL</td><td><code>progp</code> is <code>NULL</code> </td></tr>
    <tr><td class="paramname">EINVAL</td><td><code>opts</code> is invalid and/or unacceptable </td></tr>
    <tr><td class="paramname">EINVAL</td><td>the value off <code>pipidp</code> is invalid </td></tr>
    <tr><td class="paramname">EINVAL</td><td>the coreno is larger than or equal to <code>PIP_CPUCORE_CORENO_MAX</code> </td></tr>
    <tr><td class="paramname">EBUSY</td><td>specified PiP ID is alredy occupied </td></tr>
    <tr><td class="paramname">ENOMEM</td><td>not enough memory </td></tr>
    <tr><td class="paramname">ENXIO</td><td><code>dlmopen</code> failss</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Bugs</dt><dd>In theory, there is no reason to restrict for a PiP task to spawn another PiP task. However, the current glibc implementation does not allow to do so. </dd></dl>
<dl class="section user"><dt></dt><dd>If the root process is multithreaded, only the main thread can call this function.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>pip_task_spawn(3), pip_spawn_from_main(3), pip_spawn_from_func(3), pip_spawn_hook(3), pip_spawn(3), pip_blt_spawn(3) </dd></dl>

</div>
</div>
<a class="anchor" id="ga4698d85283b03f0443fb0991e1119d35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pip_spawn </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>envv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>coreno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pipidp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pip_spawnhook_t&#160;</td>
          <td class="paramname"><em>before</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pip_spawnhook_t&#160;</td>
          <td class="paramname"><em>after</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>hookarg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>Name</dt><dd>pip_spawn<a name="ga4698d85283b03f0443fb0991e1119d35_pip_spawn"></a></dd></dl>
<dl class="section user"><dt>Synopsis</dt><dd>#include &lt;<a class="el" href="pip_8h_source.html">pip.h</a>&gt; <br/>
int pip_spawn( char *filename, char **argv, char **envv, uint32_t coreno, int *pipidp, pip_spawnhook_t before, pip_spawnhook_t after, void *hookarg);</dd></dl>
<dl class="section user"><dt>Description</dt><dd>This function spawns a PiP task. </dd></dl>
<dl class="section user"><dt></dt><dd>In the process execution mode, the file descriptors having the <code>FD_CLOEXEC</code> flag is closed and will not be passed to the spawned PiP task. This simulated close-on-exec will not take place in the pthread execution mode.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>The executable to run as a PiP task </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argv</td><td>Argument(s) for the spawned PiP task </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">envv</td><td>Environment variables for the spawned PiP task </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coreno</td><td>CPU core number for the PiP task to be bound to. By default, <code>coreno</code> is set to zero, for example, then the calling task will be bound to the first core available. This is in mind that the available core numbers are not contiguous. To specify an absolute core number, <code>coreno</code> must be bitwise-ORed with <code>PIP_CPUCORE_ABS</code>. If <code>PIP_CPUCORE_ASIS</code> is specified, then the core binding will not take place. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pipidp</td><td>Specify PiP ID of the spawned PiP task. If <code>PIP_PIPID_ANY</code> is specified, then the PiP ID of the spawned PiP task is up to the PiP library and the assigned PiP ID will be returned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">before</td><td>Just before the executing of the spawned PiP task, this function is called so that file descriptors inherited from the PiP root, for example, can deal with. This is only effective with the PiP process mode. This function is called with the argument <em>hookarg</em> described below. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">after</td><td>This function is called when the PiP task terminates for the cleanup purpose. This function is called with the argument <em>hookarg</em> described below. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hookarg</td><td>The argument for the <em>before</em> and <em>after</em> function call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return 0 on success. Return an error code on error. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EPERM</td><td>PiP library is not yet initialized </td></tr>
    <tr><td class="paramname">EPERM</td><td>PiP task tries to spawn child task </td></tr>
    <tr><td class="paramname">EINVAL</td><td><code>progp</code> is <code>NULL</code> </td></tr>
    <tr><td class="paramname">EINVAL</td><td><code>opts</code> is invalid and/or unacceptable </td></tr>
    <tr><td class="paramname">EINVAL</td><td>the value off <code>pipidp</code> is invalid </td></tr>
    <tr><td class="paramname">EINVAL</td><td>the coreno is larger than or equal to <code>PIP_CPUCORE_CORENO_MAX</code> </td></tr>
    <tr><td class="paramname">EBUSY</td><td>specified PiP ID is alredy occupied </td></tr>
    <tr><td class="paramname">ENOMEM</td><td>not enough memory </td></tr>
    <tr><td class="paramname">ENXIO</td><td><code>dlmopen</code> failss</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Bugs</dt><dd>In theory, there is no reason to restrict for a PiP task to spawn another PiP task. However, the current glibc implementation does not allow to do so. </dd></dl>
<dl class="section user"><dt></dt><dd>If the root process is multithreaded, only the main thread can call this function.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>pip_task_spawn(3), pip_spawn_from_main(3), pip_spawn_from_func(3), pip_spawn_hook(3), pip_task_spawn(3), pip_blt_spawn(3) </dd></dl>

</div>
</div>
<a class="anchor" id="ga8b31bc23b6e165ae50d3bdea655539c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pip_blt_spawn </td>
          <td>(</td>
          <td class="paramtype">pip_spawn_program_t *&#160;</td>
          <td class="paramname"><em>progp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>coreno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pipidp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pip_task_t **&#160;</td>
          <td class="paramname"><em>bltp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pip_task_queue_t *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pip_spawn_hook_t *&#160;</td>
          <td class="paramname"><em>hookp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>Name</dt><dd>pip_blt_spawn<a name="ga8b31bc23b6e165ae50d3bdea655539c5_pip_blt_spawn"></a></dd></dl>
<dl class="section user"><dt>Synopsis</dt><dd>#include &lt;<a class="el" href="pip_8h_source.html">pip.h</a>&gt; <br/>
int pip_blt_spawn( pip_spawn_program_t *progp, uint32_t coreno, uint32_t opts, int *pipidp, pip_task_t **bltp, pip_task_queue_t *queue, pip_spawn_hook_t *hookp );</dd></dl>
<dl class="section user"><dt>Description</dt><dd>This function spawns a BLT (PiP task) specified by <code>progp</code>. The created annd returned BLT is another form of a PiP task. It is an opaque object, essentially a double-linked list. Thus created BLT can be enqueued or dequeued to/from a <code>pip_task_queue_t</code>. </dd></dl>
<dl class="section user"><dt></dt><dd>In the process execution mode, the file descriptors having the <code>FD_CLOEXEC</code> flag is closed and will not be passed to the spawned PiP task. This simulated close-on-exec will not take place in the pthread execution mode.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">progp</td><td><b>pip_spawn_program_t</b> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coreno</td><td>CPU core number for the PiP task to be bound to. By default, <code>coreno</code> is set to zero, for example, then the calling task will be bound to the first core available. This is in mind that the available core numbers are not contiguous. To specify an absolute core number, <code>coreno</code> must be bitwise-ORed with <code>PIP_CPUCORE_ABS</code>. If <code>PIP_CPUCORE_ASIS</code> is specified, then the core binding will not take place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opts</td><td>option flags. If <code>PIP_TASK_INACTIVE</code> is set, the created BLT is suspended and enqueued to the specified <code>queue</code>. Otherwise the BLT will schedules the BLTs in <code>queue</code>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pipidp</td><td>Specify PiP ID of the spawned PiP task. If <code>PIP_PIPID_ANY</code> is specified, then the PiP ID of the spawned PiP task is up to the PiP library and the assigned PiP ID will be returned. The PiP execution mode can also be specified (see below). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bltp</td><td>returns created BLT </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>PiP task queue. See the above <code>opts</code> description. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hookp</td><td>Hook information to be invoked before and after the program invokation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return 0 on success. Return an error code on error. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EPERM</td><td>PiP library is not yet initialized </td></tr>
    <tr><td class="paramname">EPERM</td><td>PiP task tries to spawn child task </td></tr>
    <tr><td class="paramname">EINVAL</td><td><code>progp</code> is <code>NULL</code> </td></tr>
    <tr><td class="paramname">EINVAL</td><td><code>opts</code> is invalid and/or unacceptable </td></tr>
    <tr><td class="paramname">EINVAL</td><td>the value off <code>pipidp</code> is invalid </td></tr>
    <tr><td class="paramname">EBUSY</td><td>specified PiP ID is alredy occupied </td></tr>
    <tr><td class="paramname">ENOMEM</td><td>not enough memory </td></tr>
    <tr><td class="paramname">ENXIO</td><td><code>dlmopen</code> failss</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Execution mode option</dt><dd>Users may explicitly specify the PiP execution mode. This execution mode can be categorized in two; process mode and thread mode. In the process execution mode, each PiP task may have its own file descriptors, signal handlers, and so on, just like a process. Contrastingly, in the pthread executionn mode, file descriptors and signal handlers are shared among PiP root and PiP tasks while maintaining the privatized variables. </dd></dl>
<dl class="section user"><dt></dt><dd>To spawn a PiP task in the process mode, the PiP library modifies the <b>clone()</b> flag so that the created PiP task can exhibit the alomost same way with that of normal Linux process. There are three ways implmented; using LD_PRELOAD, modifying GLIBC, and modifying GIOT entry of the <b>clone()</b> systemcall. One of the option flag values; <b>PIP_MODE_PTHREAD</b>, <b>PIP_MODE_PROCESS</b>, <b>PIP_MODE_PROCESS_PRELOAD</b>, <b>PIP_MODE_PROCESS_PIPCLONE</b>, or b PIP_MODE_PROCESS_GOT can be specified as the option flag. Or, users may specify the execution mode by the PIP_MODE environment described below.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In theory, there is no reason to restrict for a PiP task to spawn another PiP task. However, the current implementation fails to do so. If the root process is multithreaded, only the main thread can call this function.</dd></dl>
<dl class="section user"><dt>Environment</dt><dd><ul>
<li><b>PIP_MODE</b> Specifying the PiP execution mode. The value can be one of; 'process', 'process:preload', 'process:got' and 'thread' (or 'pthread'). </li>
<li><b>PIP_STACKSZ</b> Sepcifying the stack size (in bytes). The <b>KMP_STACKSIZE</b> and <b>OMP_STACKSIZE</b> can also be specified. The 't', 'g', 'm', 'k' and 'b' posfix character can be used. </li>
<li><b>PIP_STOP_ON_START</b> Specifying the PIP ID to stop on start PiP task program to debug from the beginning. If the before hook is specified, then the PiP task will be stopped just before calling the before hook. </li>
<li><b>PIP_STACKSZ</b> Sepcifying the stack size (in bytes). The <b>KMP_STACKSIZE</b> and <b>OMP_STACKSIZE</b> can also be specified. The 't', 'g', 'm', 'k' and 'b' posfix character can be used.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Bugs</dt><dd>In theory, there is no reason to restrict for a PiP task to spawn another PiP task. However, the current glibc implementation does not allow to do so. </dd></dl>
<dl class="section user"><dt></dt><dd>If the root process is multithreaded, only the main thread can call this function.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>pip_task_spawn(3), pip_spawn_from_main(3), pip_spawn_from_func(3), pip_spawn_hook(3), pip_task_spawn(3), pip_spawn(3) </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
