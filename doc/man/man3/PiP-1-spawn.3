.TH "Spawning PiP task" 3 "Sun Jan 17 2021" "Process-in-Process" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Spawning PiP task \- 
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBpip_spawn_from_main\fP (pip_spawn_program_t *progp, char *prog, char **argv, char **envv, void *exp, void *aux)"
.br
.RI "\fISetting information to invoke a PiP task starting from the main function\&. \fP"
.ti -1c
.RI "void \fBpip_spawn_from_func\fP (pip_spawn_program_t *progp, char *prog, char *funcname, void *arg, char **envv, void *exp, void *aux)"
.br
.RI "\fISetting information to invoke a PiP task starting from a function defined in a program\&. \fP"
.ti -1c
.RI "void \fBpip_spawn_hook\fP (pip_spawn_hook_t *hook, pip_spawnhook_t before, pip_spawnhook_t after, void *hookarg)"
.br
.RI "\fISetting invocation hook information\&. \fP"
.ti -1c
.RI "int \fBpip_task_spawn\fP (pip_spawn_program_t *progp, uint32_t coreno, uint32_t opts, int *pipidp, pip_spawn_hook_t *hookp)"
.br
.RI "\fISpawning a PiP task\&. \fP"
.ti -1c
.RI "int \fBpip_spawn\fP (char *filename, char **argv, char **envv, uint32_t coreno, int *pipidp, pip_spawnhook_t before, pip_spawnhook_t after, void *hookarg)"
.br
.RI "\fIspawn a PiP task (PiP v1 API and deprecated) \fP"
.ti -1c
.RI "int \fBpip_blt_spawn\fP (pip_spawn_program_t *progp, uint32_t coreno, uint32_t opts, int *pipidp, pip_task_t **bltp, pip_task_queue_t *queue, pip_spawn_hook_t *hookp)"
.br
.RI "\fIspawn a PiP BLT/ULP (Bi-Level Task / User-Level Process) \fP"
.in -1c
.SH "Detailed Description"
.PP 
PiP Spawnig PiP (ULP/BLT) task

.PP
\fBDescription\fP
.RS 4
Spawning PiP task or ULP/BLT task 
.RE
.PP

.SH "Function Documentation"
.PP 
.SS "void pip_spawn_from_main (pip_spawn_program_t *progp, char *prog, char **argv, char **envv, void *exp, void *aux)"

.PP
\fBName\fP
.RS 4
pip_spawn_from_main
.RE
.PP
\fBSynopsis\fP
.RS 4
#include <\fBpip/pip\&.h\fP> 
.br
void pip_spawn_from_main( pip_spawn_program_t *progp, char *prog, char **argv, char **envv, void *exp, void *aux )
.RE
.PP
\fBDescription\fP
.RS 4
This function sets up the \fCpip_spawn_program_t\fP structure for spawning a PiP task, starting from the mmain function\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIprogp\fP Pointer to the \fCpip_spawn_program_t\fP structure in which the program invokation information will be set 
.br
\fIprog\fP Path to the executiable file\&. 
.br
\fIargv\fP Argument vector\&. 
.br
\fIenvv\fP Environment variables\&. If this is \fCNULL\fP, then the \fCenviron\fP variable is used for the spawning PiP task\&. 
.br
\fIexp\fP Export value to the spawning PiP task 
.br
\fIaux\fP Auxiliary data to be associated with the created PiP task
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBpip_task_spawn\fP 
.PP
\fBpip_spawn_from_func\fP 
.RE
.PP

.SS "void pip_spawn_from_func (pip_spawn_program_t *progp, char *prog, char *funcname, void *arg, char **envv, void *exp, void *aux)"

.PP
\fBName\fP
.RS 4
pip_spawn_from_func
.RE
.PP
\fBSynopsis\fP
.RS 4
#include <\fBpip/pip\&.h\fP> 
.br
pip_spawn_from_func( pip_spawn_program_t *progp, char *prog, char *funcname, void *arg, char **envv, void *exp, void *aux );
.RE
.PP
\fBDescription\fP
.RS 4
This function sets the required information to invoke a program, starting from the \fCmain()\fP function\&. The function should have the function prototype as shown below; 
.PP
.nf
int start_func( void *arg )

.fi
.PP
 This start function must be globally defined in the program\&.\&. The returned integer of the start function will be treated in the same way as the \fCmain\fP function\&. This implies that the \fCpip_wait\fP function family called from the PiP root can retrieve the return code\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIprogp\fP Pointer to the \fCpip_spawn_program_t\fP structure in which the program invokation information will be set 
.br
\fIprog\fP Path to the executiable file\&. 
.br
\fIfuncname\fP Function name to be started 
.br
\fIarg\fP Argument which will be passed to the start function 
.br
\fIenvv\fP Environment variables\&. If this is \fCNULL\fP, then the \fCenviron\fP variable is used for the spawning PiP task\&. 
.br
\fIexp\fP Export value to the spawning PiP task 
.br
\fIaux\fP Auxiliary data to be associated with the created PiP task
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBpip_task_spawn\fP 
.PP
\fBpip_spawn_from_main\fP 
.RE
.PP

.SS "void pip_spawn_hook (pip_spawn_hook_t *hook, pip_spawnhook_tbefore, pip_spawnhook_tafter, void *hookarg)"

.PP
\fBName\fP
.RS 4
pip_spawn_hook
.RE
.PP
\fBSynopsis\fP
.RS 4
#include <\fBpip/pip\&.h\fP> 
.br
void pip_spawn_hook( pip_spawn_hook_t *hook, pip_spawnhook_t before, pip_spawnhook_t after, void *hookarg );
.RE
.PP
\fBDescription\fP
.RS 4

.RE
.PP
The \fIbefore\fP and \fIafter\fP functions are introduced to follow the programming model of the \fCfork\fP and \fCexec\fP\&. \fIbefore\fP function does the prologue found between the \fCfork\fP and \fCexec\fP\&. \fIafter\fP function is to free the argument if it is \fCmalloc()ed\fP, for example\&. 
.PP
\fBPrecondition:\fP
.RS 4
It should be noted that the \fIbefore\fP and \fIafter\fP functions are called in the \fIcontext\fP of PiP root, although they are running as a part of PiP task (i\&.e\&., having PID of the spawning PiP task)\&. Conversely speaking, those functions cannot access the variables defined in the spawning PiP task\&. 
.PP
The before and after hook functions should have the function prototype as shown below; 
.PP
.nf
int hook_func( void *hookarg )

.fi
.PP
.RE
.PP
\fBParameters:\fP
.RS 4
\fIhook\fP Pointer to the \fCpip_spawn_hook_t\fP structure in which the invocation hook information will be set 
.br
\fIbefore\fP Just before the executing of the spawned PiP task, this function is called so that file descriptors inherited from the PiP root, for example, can deal with\&. This is only effective with the PiP process mode\&. This function is called with the argument \fIhookarg\fP described below\&. 
.br
\fIafter\fP This function is called when the PiP task terminates for the cleanup purpose\&. This function is called with the argument \fIhookarg\fP described below\&. 
.br
\fIhookarg\fP The argument for the \fIbefore\fP and \fIafter\fP function call\&.
.RE
.PP
\fBNote:\fP
.RS 4
Note that the file descriptors and signal handlers are shared between PiP root and PiP tasks in the pthread execution mode\&.
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBpip_task_spawn\fP 
.RE
.PP

.SS "int pip_task_spawn (pip_spawn_program_t *progp, uint32_tcoreno, uint32_topts, int *pipidp, pip_spawn_hook_t *hookp)"

.PP
\fBName\fP
.RS 4
pip_task_spawn
.RE
.PP
\fBSynopsis\fP
.RS 4
#include <\fBpip/pip\&.h\fP> 
.br
int pip_task_spawn( pip_spawn_program_t *progp, uint32_t coreno, uint32_t opts, int *pipidp, pip_spawn_hook_t *hookp );
.RE
.PP
\fBDescription\fP
.RS 4
This function spawns a PiP task specified by \fCprogp\fP\&. 
.RE
.PP
\fB\fP
.RS 4
In the process execution mode, the file descriptors having the \fCFD_CLOEXEC\fP flag is closed and will not be passed to the spawned PiP task\&. This simulated close-on-exec will not take place in the pthread execution mode\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIprogp\fP \fBpip_spawn_program_t\fP 
.br
\fIcoreno\fP CPU core number for the PiP task to be bound to\&. By default, \fCcoreno\fP is set to zero, for example, then the calling task will be bound to the 'first' core available\&. This is in mind that the available core numbers are not contiguous\&. To specify an absolute core number, \fCcoreno\fP must be bitwise-ORed with \fCPIP_CPUCORE_ABS\fP\&. If \fCPIP_CPUCORE_ASIS\fP is specified, then the core binding will not take place\&. 
.br
\fIopts\fP option flags 
.br
\fIpipidp\fP Specify PiP ID of the spawned PiP task\&. If \fCPIP_PIPID_ANY\fP is specified, then the PiP ID of the spawned PiP task is up to the PiP library and the assigned PiP ID will be returned\&. 
.br
\fIhookp\fP Hook information to be invoked before and after the program invokation\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Zero is returned if this function succeeds\&. On error, an error number is returned\&. 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIEPERM\fP PiP library is not yet initialized 
.br
\fIEPERM\fP PiP task tries to spawn child task 
.br
\fIEINVAL\fP \fCprogp\fP is \fCNULL\fP 
.br
\fIEINVAL\fP \fCopts\fP is invalid and/or unacceptable 
.br
\fIEINVAL\fP the value off \fCpipidp\fP is invalid 
.br
\fIEINVAL\fP the coreno is larger than or equal to \fCPIP_CPUCORE_CORENO_MAX\fP 
.br
\fIEBUSY\fP specified PiP ID is alredy occupied 
.br
\fIENOMEM\fP not enough memory 
.br
\fIENXIO\fP \fCdlmopen\fP failss
.RE
.PP
\fBBugs\fP
.RS 4
In theory, there is no reason to restrict for a PiP task to spawn another PiP task\&. However, the current glibc implementation does not allow to do so\&. 
.RE
.PP
\fB\fP
.RS 4
If the root process is multithreaded, only the main thread can call this function\&.
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBpip_task_spawn\fP 
.PP
\fBpip_spawn_from_main\fP 
.PP
\fBpip_spawn_from_func\fP 
.PP
\fBpip_spawn_hook\fP 
.PP
\fBpip_spawn\fP 
.PP
\fBpip_blt_spawn\fP 
.RE
.PP

.SS "int pip_spawn (char *filename, char **argv, char **envv, uint32_tcoreno, int *pipidp, pip_spawnhook_tbefore, pip_spawnhook_tafter, void *hookarg)"

.PP
\fBName\fP
.RS 4
pip_spawn
.RE
.PP
\fBSynopsis\fP
.RS 4
#include <\fBpip/pip\&.h\fP> 
.br
int pip_spawn( char *filename, char **argv, char **envv, uint32_t coreno, int *pipidp, pip_spawnhook_t before, pip_spawnhook_t after, void *hookarg);
.RE
.PP
\fBDescription\fP
.RS 4
This function spawns a PiP task\&. 
.RE
.PP
\fB\fP
.RS 4
In the process execution mode, the file descriptors having the \fCFD_CLOEXEC\fP flag is closed and will not be passed to the spawned PiP task\&. This simulated close-on-exec will not take place in the pthread execution mode\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIfilename\fP The executable to run as a PiP task 
.br
\fIargv\fP Argument(s) for the spawned PiP task 
.br
\fIenvv\fP Environment variables for the spawned PiP task 
.br
\fIcoreno\fP CPU core number for the PiP task to be bound to\&. By default, \fCcoreno\fP is set to zero, for example, then the calling task will be bound to the first core available\&. This is in mind that the available core numbers are not contiguous\&. To specify an absolute core number, \fCcoreno\fP must be bitwise-ORed with \fCPIP_CPUCORE_ABS\fP\&. If \fCPIP_CPUCORE_ASIS\fP is specified, then the core binding will not take place\&. 
.br
\fIpipidp\fP Specify PiP ID of the spawned PiP task\&. If \fCPIP_PIPID_ANY\fP is specified, then the PiP ID of the spawned PiP task is up to the PiP library and the assigned PiP ID will be returned\&. 
.br
\fIbefore\fP Just before the executing of the spawned PiP task, this function is called so that file descriptors inherited from the PiP root, for example, can deal with\&. This is only effective with the PiP process mode\&. This function is called with the argument \fIhookarg\fP described below\&. 
.br
\fIafter\fP This function is called when the PiP task terminates for the cleanup purpose\&. This function is called with the argument \fIhookarg\fP described below\&. 
.br
\fIhookarg\fP The argument for the \fIbefore\fP and \fIafter\fP function call\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Return 0 on success\&. Return an error code on error\&. 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIEPERM\fP PiP library is not yet initialized 
.br
\fIEPERM\fP PiP task tries to spawn child task 
.br
\fIEINVAL\fP \fCprogp\fP is \fCNULL\fP 
.br
\fIEINVAL\fP \fCopts\fP is invalid and/or unacceptable 
.br
\fIEINVAL\fP the value off \fCpipidp\fP is invalid 
.br
\fIEINVAL\fP the coreno is larger than or equal to \fCPIP_CPUCORE_CORENO_MAX\fP 
.br
\fIEBUSY\fP specified PiP ID is alredy occupied 
.br
\fIENOMEM\fP not enough memory 
.br
\fIENXIO\fP \fCdlmopen\fP failss
.RE
.PP
\fBBugs\fP
.RS 4
In theory, there is no reason to restrict for a PiP task to spawn another PiP task\&. However, the current glibc implementation does not allow to do so\&. 
.RE
.PP
\fB\fP
.RS 4
If the root process is multithreaded, only the main thread can call this function\&.
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBpip_task_spawn\fP 
.PP
\fBpip_spawn_from_main\fP 
.PP
\fBpip_spawn_from_func\fP 
.PP
\fBpip_spawn_hook\fP 
.PP
\fBpip_task_spawn\fP 
.PP
\fBpip_blt_spawn\fP 
.RE
.PP

.SS "int pip_blt_spawn (pip_spawn_program_t *progp, uint32_tcoreno, uint32_topts, int *pipidp, pip_task_t **bltp, pip_task_queue_t *queue, pip_spawn_hook_t *hookp)"

.PP
\fBName\fP
.RS 4
pip_blt_spawn
.RE
.PP
\fBSynopsis\fP
.RS 4
#include <\fBpip/pip\&.h\fP> 
.br
int pip_blt_spawn( pip_spawn_program_t *progp, uint32_t coreno, uint32_t opts, int *pipidp, pip_task_t **bltp, pip_task_queue_t *queue, pip_spawn_hook_t *hookp );
.RE
.PP
\fBDescription\fP
.RS 4
This function spawns a BLT (PiP task) specified by \fCprogp\fP\&. The created annd returned BLT is another form of a PiP task\&. It is an opaque object, essentially a double-linked list\&. Thus created BLT can be enqueued or dequeued to/from a \fCpip_task_queue_t\fP\&. 
.RE
.PP
\fB\fP
.RS 4
In the process execution mode, the file descriptors having the \fCFD_CLOEXEC\fP flag is closed and will not be passed to the spawned PiP task\&. This simulated close-on-exec will not take place in the pthread execution mode\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIprogp\fP \fBpip_spawn_program_t\fP 
.br
\fIcoreno\fP CPU core number for the PiP task to be bound to\&. By default, \fCcoreno\fP is set to zero, for example, then the calling task will be bound to the first core available\&. This is in mind that the available core numbers are not contiguous\&. To specify an absolute core number, \fCcoreno\fP must be bitwise-ORed with \fCPIP_CPUCORE_ABS\fP\&. If \fCPIP_CPUCORE_ASIS\fP is specified, then the core binding will not take place\&. 
.br
\fIopts\fP option flags\&. If \fCPIP_TASK_INACTIVE\fP is set, the created BLT is suspended and enqueued to the specified \fCqueue\fP\&. Otherwise the BLT will schedules the BLTs in \fCqueue\fP\&. 
.br
\fIpipidp\fP Specify PiP ID of the spawned PiP task\&. If \fCPIP_PIPID_ANY\fP is specified, then the PiP ID of the spawned PiP task is up to the PiP library and the assigned PiP ID will be returned\&. The PiP execution mode can also be specified (see below)\&. 
.br
\fIbltp\fP returns created BLT 
.br
\fIqueue\fP PiP task queue\&. See the above \fCopts\fP description\&. 
.br
\fIhookp\fP Hook information to be invoked before and after the program invokation\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Return 0 on success\&. Return an error code on error\&. 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIEPERM\fP PiP library is not yet initialized 
.br
\fIEPERM\fP PiP task tries to spawn child task 
.br
\fIEINVAL\fP \fCprogp\fP is \fCNULL\fP 
.br
\fIEINVAL\fP \fCopts\fP is invalid and/or unacceptable 
.br
\fIEINVAL\fP the value off \fCpipidp\fP is invalid 
.br
\fIEBUSY\fP specified PiP ID is alredy occupied 
.br
\fIENOMEM\fP not enough memory 
.br
\fIENXIO\fP \fCdlmopen\fP failss
.RE
.PP
\fBExecution mode option\fP
.RS 4
Users may explicitly specify the PiP execution mode\&. This execution mode can be categorized in two; process mode and thread mode\&. In the process execution mode, each PiP task may have its own file descriptors, signal handlers, and so on, just like a process\&. Contrastingly, in the pthread executionn mode, file descriptors and signal handlers are shared among PiP root and PiP tasks while maintaining the privatized variables\&. 
.RE
.PP
\fB\fP
.RS 4
To spawn a PiP task in the process mode, the PiP library modifies the \fBclone()\fP flag so that the created PiP task can exhibit the alomost same way with that of normal Linux process\&. There are three ways implmented; using LD_PRELOAD, modifying GLIBC, and modifying GIOT entry of the \fBclone()\fP systemcall\&. One of the option flag values; \fBPIP_MODE_PTHREAD\fP, \fBPIP_MODE_PROCESS\fP, \fBPIP_MODE_PROCESS_PRELOAD\fP, \fBPIP_MODE_PROCESS_PIPCLONE\fP, or b PIP_MODE_PROCESS_GOT can be specified as the option flag\&. Or, users may specify the execution mode by the PIP_MODE environment described below\&.
.RE
.PP
\fBNote:\fP
.RS 4
In theory, there is no reason to restrict for a PiP task to spawn another PiP task\&. However, the current implementation fails to do so\&. If the root process is multithreaded, only the main thread can call this function\&.
.RE
.PP
\fBEnvironment\fP
.RS 4

.PD 0

.IP "\(bu" 2
\fBPIP_MODE\fP Specifying the PiP execution mode\&. The value can be one of; 'process', 'process:preload', 'process:got' and 'thread' (or 'pthread')\&. 
.IP "\(bu" 2
\fBPIP_STACKSZ\fP Sepcifying the stack size (in bytes)\&. The \fBKMP_STACKSIZE\fP and \fBOMP_STACKSIZE\fP can also be specified\&. The 't', 'g', 'm', 'k' and 'b' posfix character can be used\&. 
.IP "\(bu" 2
\fBPIP_STOP_ON_START\fP Specifying the PIP ID to stop on start PiP task program to debug from the beginning\&. If the before hook is specified, then the PiP task will be stopped just before calling the before hook\&. 
.IP "\(bu" 2
\fBPIP_STACKSZ\fP Sepcifying the stack size (in bytes)\&. The \fBKMP_STACKSIZE\fP and \fBOMP_STACKSIZE\fP can also be specified\&. The 't', 'g', 'm', 'k' and 'b' posfix character can be used\&.
.PP
.RE
.PP
\fBBugs\fP
.RS 4
In theory, there is no reason to restrict for a PiP task to spawn another PiP task\&. However, the current glibc implementation does not allow to do so\&. 
.RE
.PP
\fB\fP
.RS 4
If the root process is multithreaded, only the main thread can call this function\&.
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBpip_task_spawn\fP 
.PP
\fBpip_spawn_from_main\fP 
.PP
\fBpip_spawn_from_func\fP 
.PP
\fBpip_spawn_hook\fP 
.PP
\fBpip_task_spawn\fP 
.PP
\fBpip_spawn\fP 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Process-in-Process from the source code\&.
