.TH "Suspending and Resuming BLT/ULP" 3 "Mon Jul 6 2020" "Process-in-Process" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Suspending and Resuming BLT/ULP \- 
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBpip_suspend_and_enqueue\fP (pip_task_queue_t *queue, pip_enqueue_callback_t callback, void *cbarg)"
.br
.ti -1c
.RI "int \fBpip_suspend_and_enqueue_nolock\fP (pip_task_queue_t *queue, pip_enqueue_callback_t callback, void *cbarg)"
.br
.ti -1c
.RI "int \fBpip_dequeue_and_resume\fP (pip_task_queue_t *queue, pip_task_t *sched)"
.br
.ti -1c
.RI "int \fBpip_dequeue_and_resume_nolock\fP (pip_task_queue_t *queue, pip_task_t *sched)"
.br
.ti -1c
.RI "int \fBpip_dequeue_and_resume_N\fP (pip_task_queue_t *queue, pip_task_t *sched, int *np)"
.br
.ti -1c
.RI "int \fBpip_dequeue_and_resume_N_nolock\fP (pip_task_queue_t *queue, pip_task_t *sched, int *np)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Suspending and resuming BLT/ULP

.PP
\fBDescription\fP
.RS 4
Suspending and resuming BLT/ULP 
.RE
.PP

.SS "pip_suspend_and_enqueue"
suspend the curren task and enqueue it with lock
.PP
\fBSynopsis\fP
.RS 4
#include <\fBpip\&.h\fP> 
.br
 int pip_suspend_and_enqueue( pip_task_queue_t *queue, pip_enqueue_callback_t callback, void *cbarg );
.RE
.PP
\fBDescription\fP
.RS 4
The \fBqueue\fP is locked just before the calling task is enqueued and unlocked after the calling task is enqueued\&. After then the \fBcallback\fP function is called\&. 
.RE
.PP
\fB\fP
.RS 4
As the result of this suspension, a context-switch takes place if there is at least one elgible-to-run task in the scheduling queue (this is hidden from users)\&. If there is no other task to schedule then the kernel thread of the current task will be blocked\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIqueue\fP A task queue 
.br
\fIcallback\fP A callback function which is called immediately after the task is enqueued 
.br
\fIcbarg\fP An argument given to the callback function
.RE
.PP
\fBReturns:\fP
.RS 4
Return 0 on success\&. Return an error code on error\&. 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIEPERM\fP PiP library is not initialized yet 
.br
\fIEINVAL\fP \fCqueue\fP is \fCNULL\fP 
.RE
.PP
\fBSee Also:\fP
.RS 4
pip_enqueu_and_suspend_nolock(3), pip_dequeue_and_resume(3) 
.RE
.PP

.SS "pip_suspend_and_enqueue_nolock"
suspend the curren task and enqueue it without locking the queue
.PP
\fBSynopsis\fP
.RS 4
#include <\fBpip\&.h\fP> 
.br
 int pip_suspend_and_enqueue_nolock( pip_task_queue_t *queue, pip_enqueue_callback_t callback, void *cbarg );
.RE
.PP
\fBDescription\fP
.RS 4
Unlike \fCpip_suspend_and_enqueue\fP, this function never locks the queue\&. It is the user's responsibility to lock the queue beofre calling this function and unlock the queue after calling this function\&. The \fBcallback\fP function can be used for unlocking\&. 
.RE
.PP
\fB\fP
.RS 4
As the result of this suspension, a context-switch takes place if there is at least one elgible-to-run task in the scheduling queue (this is hidden from users)\&. If there is no other task to schedule then the kernel thread of the current task will be blocked\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIqueue\fP A task queue 
.br
\fIcallback\fP A callback function which is called when enqueued 
.br
\fIcbarg\fP An argument given to the callback function
.RE
.PP
\fBReturns:\fP
.RS 4
Return 0 on success\&. Return an error code on error\&. 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIEPERM\fP PiP library is not initialized yet 
.br
\fIEINVAL\fP \fCqueue\fP is \fCNULL\fP 
.RE
.PP

.SS "pip_dequeue_and_resume"
dequeue a task and make it runnable
.PP
\fBDescription\fP
.RS 4
The \fBqueue\fP is locked and then unlocked when to dequeued a task\&.
.RE
.PP
\fBSynopsis\fP
.RS 4
#include <\fBpip\&.h\fP> 
.br
int pip_dequeue_and_resume( pip_task_queue_t *queue, pip_task_t *sched );
.RE
.PP
\fBParameters:\fP
.RS 4
\fIqueue\fP A task queue 
.br
\fIsched\fP A task to specify a scheduling domain
.RE
.PP
\fBReturns:\fP
.RS 4
If succeedss, 0 is returned\&. Otherwise an error code is returned\&. 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIEPERM\fP PiP library is not initialized yet 
.br
\fIEINVAL\fP \fCqueue\fP is \fCNULL\fP 
.br
\fIENOENT\fP \fCqueue\fP is empty\&. 
.RE
.PP

.SS "pip_dequeue_and_resume_nolock"
dequeue a task and make it runnable
.PP
\fBSynopsis\fP
.RS 4
#include <\fBpip\&.h\fP> 
.br
int pip_dequeue_and_resume( pip_task_queue_t *queue, pip_task_t *sched );
.RE
.PP
\fBDescription\fP
.RS 4
Task in the queue is dequeued and scheduled by the specified \fCsched\fP\&. If \fCsched\fP is NULL, then the task is enqueued into the scheduling queue of calling task\&. 
.RE
.PP
\fB\fP
.RS 4
It is the user's responsibility to lock the queue beofre calling this function and unlock the queue after calling this function\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIqueue\fP A task queue 
.br
\fIsched\fP A task to specify a scheduling domain
.RE
.PP
\fBReturns:\fP
.RS 4
This function returns no error 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIEPERM\fP PiP library is not initialized yet 
.br
\fIEINVAL\fP \fCqueue\fP is \fCNULL\fP 
.br
\fIENOENT\fP \fCqueue\fP is empty\&. 
.RE
.PP

.SS "pip_dequeue_and_resume_N"
dequeue multiple tasks and resume the execution of them
.PP
\fBSynopsis\fP
.RS 4
#include <\fBpip\&.h\fP> 
.br
 int pip_dequeue_and_resume_N( pip_task_queue_t *queue, pip_task_t *sched, int *np );
.RE
.PP
\fBDescription\fP
.RS 4
The specified number of tasks are dequeued and scheduled by the specified \fCsched\fP\&. If \fCsched\fP is NULL, then the task is enqueued into the scheduling queue of calling task\&. 
.RE
.PP
\fB\fP
.RS 4
The \fBqueue\fP is locked and unlocked when dequeued\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIqueue\fP A task queue 
.br
\fIsched\fP A task to specify a scheduling domain 
.br
\fInp\fP A pointer to an interger which spcifies the number of tasks dequeued and actual number of tasks dequeued is returned\&. When \fCPIP_TASK_ALL\fP is specified, then all tasks in the queue will be resumed\&.
.RE
.PP
\fBReturns:\fP
.RS 4
This function returns no error 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIEPERM\fP PiP library is not initialized yet 
.br
\fIEINVAL\fP \fCqueue\fP is \fCNULL\fP 
.br
\fIEINVAL\fP the specified number of tasks is invalid 
.br
\fIENOENT\fP \fCqueue\fP is empty\&.
.RE
.PP
It is the user's responsibility to lock the queue beofre calling this function and unlock the queue after calling this function\&. 
.SS "pip_dequeue_and_resume_N_nolock"
dequeue tasks and resume the execution of them
.PP
\fBSynopsis\fP
.RS 4
#include <\fBpip\&.h\fP> 
.br
 int pip_dequeue_and_resume_N_nolock( pip_task_queue_t *queue, pip_task_t *sched, int *np );
.RE
.PP
\fBDescription\fP
.RS 4
The specified number of tasks are dequeued and scheduled by the specified \fCsched\fP\&. If \fCsched\fP is NULL, then the task is enqueued into the scheduling queue of calling task\&. 
.RE
.PP
\fB\fP
.RS 4
It is the user's responsibility to lock the queue beofre calling this function and unlock the queue after calling this function\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIqueue\fP A task queue 
.br
\fIsched\fP A task to specify a scheduling domain 
.br
\fInp\fP A pointer to an interger which spcifies the number of tasks dequeued and actual number of tasks dequeued is returned\&. When \fCPIP_TASK_ALL\fP is specified, then all tasks in the queue will be resumed\&.
.RE
.PP
\fBReturns:\fP
.RS 4
This function returns no error 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIEPERM\fP PiP library is not initialized yet 
.br
\fIEINVAL\fP \fCqueue\fP is \fCNULL\fP 
.br
\fIEINVAL\fP the specified number of tasks is invalid 
.br
\fIENOENT\fP \fCqueue\fP is empty\&. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Process-in-Process from the source code\&.
