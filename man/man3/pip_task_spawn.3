.TH "pip_task_spawn" 3 "Wed Jul 1 2020" "PiP - Process-in-Process" \" -*- nroff -*-
.ad l
.nh
.SH NAME
pip_task_spawn \- pip_task_spawn 
Spawning a PiP task
.PP
\fBSynopsis:\fP
.RS 4
#include <\fBpip\&.h\fP> 
.br
int pip_task_spawn( pip_spawn_program_t *progp, uint32_t coreno, uint32_t opts, int *pipidp, pip_spawn_hook_t *hookp );
.RE
.PP
\fBDescription:\fP
.RS 4
This function spawns a PiP task specified by \fCprogp\fP\&. 
.RE
.PP
\fB\fP
.RS 4
In the process execution mode, the file descriptors having the \fCFD_CLOEXEC\fP flag is closed and will not be passed to the spawned PiP task\&. This simulated close-on-exec will not take place in the pthread execution mode\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIprogp\fP Program information to spawn as a PiP task 
.br
\fIcoreno\fP Core number for the PiP task to be bound to\&. If \fCPIP_CPUCORE_ASIS\fP is specified, then the core binding will not take place\&. 
.br
\fIopts\fP option flags 
.br
\fIpipidp\fP Specify PiP ID of the spawned PiP task\&. If \fCPIP_PIPID_ANY\fP is specified, then the PiP ID of the spawned PiP task is up to the PiP library and the assigned PiP ID will be returned\&. 
.br
\fIhookp\fP Hook information to be invoked before and after the program invokation\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Zero is returned if this function succeeds\&. On error, an error number is returned\&. 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIEPERM\fP PiP library is not yet initialized 
.br
\fIEPERM\fP PiP task tries to spawn child task 
.br
\fIEINVAL\fP \fCprogp\fP is \fCNULL\fP 
.br
\fIEINVAL\fP \fCopts\fP is invalid and/or unacceptable 
.br
\fIEINVAL\fP the value off \fCpipidp\fP is invalid 
.br
\fIEBUSY\fP specified PiP ID is alredy occupied 
.br
\fIENOMEM\fP not enough memory 
.br
\fIENXIO\fP \fCdlmopen\fP failss
.RE
.PP
\fBNote:\fP
.RS 4
In the process execution mode, each PiP task may have its own file descriptors, signal handlers, and so on, just like a process\&. Contrastingly, in the pthread executionn mode, file descriptors and signal handlers are shared among PiP root and PiP tasks while maintaining the privatized variables\&.
.RE
.PP
\fBBugs:\fP
.RS 4
In theory, there is no reason to restrict for a PiP task to spawn another PiP task\&. However, the current glibc implementation does not allow to do so\&. 
.RE
.PP
\fB\fP
.RS 4
If the root process is multithreaded, only the main thread can call this function\&.
.RE
.PP
\fBSee Also:\fP
.RS 4
pip_task_spawn(3), pip_spawn_from_main(3), pip_spawn_from_func(3), pip_spawn_hook(3) 
.RE
.PP

