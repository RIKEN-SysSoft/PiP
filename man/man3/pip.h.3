.TH "pip.h" 3 "Wed Dec 26 2018" "PiP - Process-in-Process" \" -*- nroff -*-
.ad l
.nh
.SH NAME
pip.h \- 
.SH SYNOPSIS
.br
.PP
.SS "Functions"

.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "int \fBpip_init\fP (int *pipidp, int *ntasks, void **root_expp, int opts)"
.br
.RI "\fIInitialize the PiP library\&. \fP"
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "int \fBpip_fin\fP (void)"
.br
.RI "\fIfinalize the PiP library\&. \fP"
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "int \fBpip_spawn\fP (char *filename, char **argv, char **envv, int coreno, int *pipidp, pip_spawnhook_t before, pip_spawnhook_t after, void *hookarg)"
.br
.RI "\fIspawn a PiP task \fP"
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "int \fBpip_export\fP (void *exp)"
.br
.RI "\fIexport a memory region of the calling PiP root or a PiP task to the others\&. \fP"
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "int \fBpip_import\fP (int pipid, void **expp)"
.br
.RI "\fIimport the exposed memory region of the other\&. \fP"
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "int \fBpip_get_addr\fP (int pipid, const char *symnam, void **addrp)"
.br
.RI "\fIimport the exposed memory region of the other\&. \fP"
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "int \fBpip_get_pipid\fP (int *pipidp)"
.br
.RI "\fIget PIPID \fP"
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "int \fBpip_get_ntasks\fP (int *ntasksp)"
.br
.RI "\fIget the maximum number of the PiP tasks \fP"
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "int \fBpip_isa_piptask\fP (void)"
.br
.RI "\fIcheck if the calling task is a PiP task or not \fP"
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "int \fBpip_get_mode\fP (int *modep)"
.br
.RI "\fIget the PiP execution mode \fP"
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "int \fBpip_exit\fP (int retval)"
.br
.RI "\fIterminate PiP task \fP"
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "int \fBpip_wait\fP (int pipid, int *retval)"
.br
.RI "\fIwait for the termination of a PiP task \fP"
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "int \fBpip_trywait\fP (int pipid, int *retval)"
.br
.RI "\fIwait for the termination of a PiP task in a non-blocking way \fP"
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "int \fBpip_kill\fP (int pipid, int signal)"
.br
.RI "\fIdeliver a signal to a PiP task \fP"
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "int \fBpip_get_id\fP (int pipid, intptr_t *idp)"
.br
.RI "\fIdeliver a process or thread ID \fP"
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "const char * \fBpip_get_mode_str\fP (void)"
.br
.RI "\fIget a string of the current execution mode \fP"
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "void \fBpip_barrier_init\fP (pip_barrier_t *barrp, int n)"
.br
.RI "\fIinitialize barrier synchronization structure \fP"
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "void \fBpip_barrier_wait\fP (pip_barrier_t *barrp)"
.br
.RI "\fIwait on barrier synchronization in a busy-wait way \fP"
.in -1c
.in -1c
.SH "Author"
.PP 
Generated automatically by Doxygen for PiP - Process-in-Process from the source code\&.
