.TH "libpip" 3 "Sat Feb 16 2019" "PiP - Process-in-Process" \" -*- nroff -*-
.ad l
.nh
.SH NAME
libpip \- 
.PP
the PiP library  

.in +1c
.ti -1c
.RI "int \fBpip_init\fP (int *pipidp, int *ntasks, void **root_expp, int opts)"
.br
.RI "\fIInitialize the PiP library\&. \fP"
.in -1c
.in +1c
.ti -1c
.RI "int \fBpip_fin\fP (void)"
.br
.RI "\fIfinalize the PiP library\&. \fP"
.in -1c
.in +1c
.ti -1c
.RI "int \fBpip_task_spawn\fP (pip_spawn_program_t *progp, int coreno, uint32_t opts, int *pipidp, pip_spawn_hook_t *hookp)"
.br
.RI "\fIspawn a PiP task (PiP API Version 2) \fP"
.in -1c
.in +1c
.ti -1c
.RI "int \fBpip_named_export\fP (void *exp, const char *format,\&.\&.\&.)"
.br
.RI "\fIexport an address of the calling PiP root or a PiP task to the others\&. \fP"
.in -1c
.in +1c
.ti -1c
.RI "int \fBpip_named_import\fP (int pipid, void **expp, const char *format,\&.\&.\&.)"
.br
.RI "\fIimport the exposed memory region of the other\&. \fP"
.in -1c
.in +1c
.ti -1c
.RI "int \fBpip_named_tryimport\fP (int pipid, void **expp, const char *format,\&.\&.\&.)"
.br
.RI "\fInon-blocking version of \fCpip_named_import\fP \fP"
.in -1c
.in +1c
.ti -1c
.RI "int \fBpip_export\fP (void *exp)"
.br
.RI "\fIexport a memory region of the calling PiP root or a PiP task to the others\&. \fP"
.in -1c
.in +1c
.ti -1c
.RI "int \fBpip_import\fP (int pipid, void **expp)"
.br
.RI "\fIimport the exposed memory region of the other\&. \fP"
.in -1c
.in +1c
.ti -1c
.RI "int \fBpip_get_pipid\fP (int *pipidp)"
.br
.RI "\fIget PiP ID \fP"
.in -1c
.in +1c
.ti -1c
.RI "int \fBpip_is_initialized\fP (void)"
.br
.RI "\fIQuery is PiP library is already initialized\&. \fP"
.ti -1c
.RI "int \fBpip_get_ntasks\fP (int *ntasksp)"
.br
.RI "\fIget the maximum number of the PiP tasks \fP"
.in -1c
.in +1c
.ti -1c
.RI "int \fBpip_isa_piptask\fP (void)"
.br
.RI "\fIcheck if the calling task is a PiP task or not \fP"
.in -1c
.in +1c
.ti -1c
.RI "int \fBpip_count_active_tasks\fP (void)"
.br
.RI "\fIreturn the number of active tasks \fP"
.in -1c
.in +1c
.ti -1c
.RI "int \fBpip_get_mode\fP (int *modep)"
.br
.RI "\fIget the PiP execution mode \fP"
.in -1c
.in +1c
.ti -1c
.RI "int \fBpip_exit\fP (int retval)"
.br
.RI "\fIterminate PiP task or ULP \fP"
.in -1c
.in +1c
.ti -1c
.RI "int \fBpip_wait\fP (int pipid, int *retval)"
.br
.RI "\fIwait for the termination of a PiP task \fP"
.in -1c
.in +1c
.ti -1c
.RI "int \fBpip_trywait\fP (int pipid, int *retval)"
.br
.RI "\fIwait for the termination of a PiP task in a non-blocking way \fP"
.in -1c
.in +1c
.ti -1c
.RI "int \fBpip_wait_any\fP (int *pipid, int *retval)"
.br
.RI "\fIwait for the termination of any PiP task \fP"
.in -1c
.in +1c
.ti -1c
.RI "int \fBpip_trywait_any\fP (int *pipid, int *retval)"
.br
.RI "\fIwait for the termination of any PiP task \fP"
.in -1c
.in +1c
.ti -1c
.RI "int \fBpip_kill\fP (int pipid, int signal)"
.br
.RI "\fIdeliver a signal to a PiP task \fP"
.in -1c
.in +1c
.ti -1c
.RI "int \fBpip_get_id\fP (int pipid, intptr_t *idp)"
.br
.RI "\fIdeliver a process or thread ID defined by the system \fP"
.in -1c
.in +1c
.ti -1c
.RI "const char * \fBpip_get_mode_str\fP (void)"
.br
.RI "\fIget a string of the current execution mode \fP"
.in -1c
.in +1c
.ti -1c
.RI "int \fBpip_isa_root\fP (void)"
.br
.RI "\fIcheck if calling PiP task is PiP root or not \fP"
.in -1c
.in +1c
.ti -1c
.RI "int \fBpip_isa_task\fP (void)"
.br
.RI "\fIcheck if calling PiP task is a PiP task or not \fP"
.in -1c
.in +1c
.ti -1c
.RI "int \fBpip_isa_ulp\fP (void)"
.br
.RI "\fIcheck if calling PiP task is a PiP ULP or not \fP"
.in -1c
.in +1c
.ti -1c
.RI "int \fBpip_is_alive\fP (int pipid)"
.br
.RI "\fIcheck if the specified PiP task is alive or not \fP"
.in -1c
.in +1c
.ti -1c
.RI "int \fBpip_spawn\fP (char *filename, char **argv, char **envv, int coreno, int *pipidp, pip_spawnhook_t before, pip_spawnhook_t after, void *hookarg)"
.br
.RI "\fIspawn a PiP task (ULP API Version 1) \fP"
.in -1c
.SH "Detailed Description"
.PP 
the PiP library 


.SH "Function Documentation"
.PP 
.SS "int pip_init (int *pipidp, int *ntasks, void **root_expp, intopts)"

.PP
Initialize the PiP library\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpipidp\fP When this is called by the PiP root process, then this returns \fCPIP_PIPID_ROOT\fP, otherwise it returns the PiP ID of the calling PiP task\&. 
.br
\fIntasks\fP When called by the PiP root, it specifies the maximum number of PiP tasks\&. When called by a PiP task, then it returns the number specified by the PiP root\&. 
.br
\fIroot_expp\fP If the root PiP is ready to export a memory region to any PiP task(s), then this parameter points to the variable holding the exporting address of the root PiP\&. If the PiP root is not ready to export or has nothing to export then this variable can be NULL\&. When called by a PiP task, it returns the exporting address of the PiP root, if any\&. 
.br
\fIopts\fP This must be zero at the point of this writing\&.
.RE
.PP
\fBReturns:\fP
.RS 4
zero is returned if this function succeeds\&. On error, an error number is returned\&. 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIEINVAL\fP \fInotasks\fP is a negative number, or the option combination is ivalid 
.br
\fIEOVERFLOW\fP \fCnotasks\fP is too latrge 
.br
\fIENOMEM\fP unable to allocate memory
.RE
.PP
This function initializes the PiP library\&. The PiP root process must call this\&. A PiP task is not required to call this function unless the PiP task calls any PiP functions\&.
.PP
Is is NOT guaranteed that users can spawn tasks up to the number specified by the \fIntasks\fP argument\&. There are some limitations come from outside of the PiP library (GLIBC)\&.
.PP
\fBSee Also:\fP
.RS 4
pip_export(3), pip_fin(3) 
.RE
.PP

.SS "int pip_fin (void)"

.PP
finalize the PiP library\&. 
.PP
\fBReturns:\fP
.RS 4
zero is returned if this function succeeds\&. On error, error number is returned\&. 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIEBUSY\fP \fCone\fP or more PiP tasks is yet running
.RE
.PP
This function finalize the PiP library\&.
.PP
\fBSee Also:\fP
.RS 4
pip_init(3) 
.RE
.PP

.SS "int pip_task_spawn (pip_spawn_program_t *progp, intcoreno, uint32_topts, int *pipidp, pip_spawn_hook_t *hookp)"

.PP
spawn a PiP task (PiP API Version 2) 
.PP
\fBParameters:\fP
.RS 4
\fIprogp\fP Program information to spawn as a PiP task 
.br
\fIcoreno\fP Core number for the PiP task to be bound to\&. If \fCPIP_CPUCORE_ASIS\fP is specified, then the core binding will not take place\&. 
.br
\fIopts\fP option flags 
.br
\fIpipidp\fP Specify PiP ID of the spawned PiP task\&. If \fCPIP_PIPID_ANY\fP is specified, then the PiP ID of the spawned PiP task is up to the PiP library and the assigned PiP ID will be returned\&. 
.br
\fIhookp\fP Hook information to be invoked before and after the program invokation\&.
.RE
.PP
\fBNote:\fP
.RS 4
In theory, there is no reason to restrict for a PiP task to spawn another PiP task\&. However, the current implementation fails to do so\&. If the root process is multithreaded, only the main thread can call this function\&. 
.PP
In the process mode, the file descriptors set the close-on-exec flag will be closed on the created child task\&.
.RE
.PP
\fBReturns:\fP
.RS 4
zero is returned if this function succeeds\&. On error, an error number is returned\&. 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIEPERM\fP PiP task tries to spawn child task 
.br
\fIEBUSY\fP Specified PiP ID is alredy occupied
.RE
.PP
\fBSee Also:\fP
.RS 4
pip_task_spawn(3), pip_spawn_from_main(3) 
.RE
.PP

.SS "int pip_named_export (void *exp, const char *format, \&.\&.\&.)"

.PP
export an address of the calling PiP root or a PiP task to the others\&. 
.PP
\fBParameters:\fP
.RS 4
\fIexp\fP Starting address of a memory region of the calling process or task so that the other tasks can access\&. 
.br
\fIformat\fP a \fCprintf\fP format to give the exported address a name
.RE
.PP
\fBReturns:\fP
.RS 4
Return 0 on success\&. Return an error code on error\&.
.RE
.PP
The PiP root or a PiP task can export a memory region only once\&.
.PP
\fBNote:\fP
.RS 4
The exported address can only be retrieved by \fBpip_named_import(3)\fP\&. 
.PP
There is no size parameter to specify the length of the exported region because there is no way to restrict the access outside of the exported region\&. 
.PP
The design of this function is prioritized for ease of use and this function works not in an efficient way\&. So, do not use this in a time critical path\&.
.RE
.PP
\fBReturns:\fP
.RS 4
zero is returned if this function succeeds\&. On error, an error number is returned\&. 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIEINVAL\fP \fCformat\fP is \fCNULL\fP 
.br
\fIENOMEM\fP not enough memory available 
.br
\fIEBUSY\fP the specified name is already in use
.RE
.PP
\fBSee Also:\fP
.RS 4
pip_named_import(3) 
.RE
.PP

.SS "int pip_named_import (intpipid, void **expp, const char *format, \&.\&.\&.)"

.PP
import the exposed memory region of the other\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpipid\fP The PiP ID to import the exposed address 
.br
\fIexpp\fP The starting address of the exposed region of the PiP task specified by the \fIpipid\fP\&. 
.br
\fIformat\fP a \fCprintf\fP format to give the exported address a name
.RE
.PP
\fBNote:\fP
.RS 4
To avoid deadlock, the corresponding \fBpip_named_export(3)\fP must be called beofre calling \fBpip_named_import(3)\fP; 
.PP
Unlike \fBpip_import(3)\fP, this function might be blocked until the target address is exported by the target task\&. Once a name is associated by an address, the address associated with the name cannot be changed\&. 
.PP
If this function is called by a task having passive task(s), then this call may result in context switching to the other passive task\&. 
.PP
The design of this function is prioritized for ease of use and this function works not in a efficient way\&. So, do not use this in a time critical path\&.
.RE
.PP
\fBReturns:\fP
.RS 4
zero is returned if this function succeeds\&. On error, an error number is returned\&. 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIEINVAL\fP \fCformat\fP is \fCNULL\fP 
.br
\fIENOMEM\fP not enough memory available 
.br
\fIECANCELED\fP the target task is terminated during the query
.RE
.PP
\fBSee Also:\fP
.RS 4
pip_named_export(3), pip_export(3), pip_import(3) 
.RE
.PP

.SS "int pip_named_tryimport (intpipid, void **expp, const char *format, \&.\&.\&.)"

.PP
non-blocking version of \fCpip_named_import\fP 
.PP
\fBParameters:\fP
.RS 4
\fIpipid\fP The PiP ID to import the exposed address 
.br
\fIexpp\fP The starting address of the exposed region of the PiP task specified by the \fIpipid\fP\&. 
.br
\fIformat\fP a \fCprintf\fP format to give the exported address a name
.RE
.PP
\fBNote:\fP
.RS 4
The imported address must be exported by \fBpip_named_export(3)\fP\&. 
.PP
When the named export cannot be found at the specified task, then this function returns immediately\&. It is guaranteed that the will be no task context switching take place in this function call\&.
.RE
.PP
\fBReturns:\fP
.RS 4
zero is returned if this function succeeds\&. On error, an error number is returned\&. 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIEINVAL\fP \fCformat\fP is \fCNULL\fP 
.br
\fIENOMEM\fP not enough memory available 
.br
\fIECANCELED\fP the target task is terminated during the query 
.br
\fIENOENT\fP there is no export having the specified name
.RE
.PP
\fBSee Also:\fP
.RS 4
pip_named_export(3), pip_export(3), pip_import(3) 
.RE
.PP

.SS "int pip_export (void *exp)"

.PP
export a memory region of the calling PiP root or a PiP task to the others\&. 
.PP
\fBParameters:\fP
.RS 4
\fIexp\fP Starting address of a memory region of the calling process or task to the others\&. function call\&.
.RE
.PP
The PiP root or a PiP task can export a memory region only once\&.
.PP
\fBNote:\fP
.RS 4
There is no size parameter to specify the length of the exported region because there is no way to restrict the access outside of the exported region\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Return 0 on success\&. Return an error code on error\&.
.RE
.PP
\fBSee Also:\fP
.RS 4
pip_import(3), pip_named_export(3), pip_named_import(3) 
.RE
.PP

.SS "int pip_import (intpipid, void **expp)"

.PP
import the exposed memory region of the other\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpipid\fP The PiP ID to import the exposed address 
.br
\fIexpp\fP The starting address of the exposed region of the PiP task specified by the \fIpipid\fP\&.
.RE
.PP
\fBNote:\fP
.RS 4
It is the users' responsibility to synchronize\&. When the target region is not exported yet , then this function returns NULL\&. If the root exports its region by the \fB\fBpip_init()\fP\fP function call, then it is guaranteed to be imported by PiP tasks at any time\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Return 0 on success\&. Return an error code on error\&. 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIEINVAL\fP \fCexpp\fP is \fCNULL\fP 
.RE
.PP
\fBSee Also:\fP
.RS 4
pip_export(3), pip_named_export(3), pip_named_import(3) 
.RE
.PP

.SS "int pip_get_pipid (int *pipidp)"

.PP
get PiP ID 
.PP
\fBParameters:\fP
.RS 4
\fIpipidp\fP This parameter points to the variable which will be set to the PiP ID of the calling process\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Return 0 on success\&. Return an error code on error\&. 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIEINVAL\fP \fCpipidp\fP is \fCNULL\fP 
.RE
.PP

.SS "int pip_is_initialized (void)"

.PP
Query is PiP library is already initialized\&. 
.PP
\fBReturns:\fP
.RS 4
Return 0 on success\&. Return an error code on error\&. 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fI\\c\fP true if it is already initialized 
.RE
.PP

.SS "int pip_get_ntasks (int *ntasksp)"

.PP
get the maximum number of the PiP tasks 
.PP
\fBParameters:\fP
.RS 4
\fIntasksp\fP This parameter points to the variable which will be set to the maximum number of the PiP tasks\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Return 0 on success\&. Return an error code on error\&. 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIEINVAL\fP \fCntasksp\fP is \fCNULL\fP 
.br
\fIEPERM\fP PiP library is not yet initialized 
.RE
.PP

.SS "int pip_isa_piptask (void)"

.PP
check if the calling task is a PiP task or not 
.PP
\fBReturns:\fP
.RS 4
Return an boolean value\&.
.RE
.PP
\fBNote:\fP
.RS 4
Unlike most of the other PiP functions, this can be called BEFORE calling the \fB\fBpip_init()\fP\fP function\&. 
.RE
.PP

.SS "int pip_count_active_tasks (void)"

.PP
return the number of active tasks 
.PP
\fBReturns:\fP
.RS 4
Return the number of awake tasks 
.RE
.PP

.SS "int pip_get_mode (int *modep)"

.PP
get the PiP execution mode 
.PP
\fBParameters:\fP
.RS 4
\fImodep\fP This parameter points to the variable which will be set to the PiP execution mode
.RE
.PP
\fBReturns:\fP
.RS 4
Return 0 on success\&. Return an error code on error\&. 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIEINVAL\fP \fCmodep\fP is \fCNULL\fP 
.br
\fIEPERM\fP PiP library is not yet initialized 
.RE
.PP

.SS "int pip_exit (intretval)"

.PP
terminate PiP task or ULP 
.PP
\fBParameters:\fP
.RS 4
\fIretval\fP Terminate PiP task or ULP with the exit number specified with this parameter\&.
.RE
.PP
\fBNote:\fP
.RS 4
This function can be used regardless to the PiP execution mode\&. 
.PP
If this function is called by a PiP task having one or more ULPs then the actual termination of the PiP task is postponed until all the associated (scheduling) ULP(s) terminate(s)\&.
.RE
.PP
\fBReturns:\fP
.RS 4
This function does not return if it succeeds\&. It return an error code on error\&.
.RE
.PP
\fBSee Also:\fP
.RS 4
pip_wait(3), pip_trywait(3), pip_wait_any(3), pip_trywait_any(3) 
.RE
.PP

.SS "int pip_wait (intpipid, int *retval)"

.PP
wait for the termination of a PiP task 
.PP
\fBParameters:\fP
.RS 4
\fIpipid\fP PiP ID to wait for\&. 
.br
\fIretval\fP Exit value of the terminated PiP task
.RE
.PP
\fBNote:\fP
.RS 4
This function blocks until the specified PiP task or ULP terminates\&. 
.PP
This function can be used regardless to the PiP execution mode\&. 
.PP
Only the least significant 2 bytes of the exit value are effective\&. This is because of the compatibility with the \fCexit\fP glibc function\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Return 0 on success\&. Return an error code on error\&. 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIEPERM\fP The caller is not the PiP root 
.br
\fIEDEADLK\fP The specified \fCpipid\fP is the PiP root 
.br
\fIEINTR\fP The call was interrupted by a signal
.RE
.PP
\fBSee Also:\fP
.RS 4
pip_exit(3), pip_trywait(3), pip_wait_any(3), pip_trywait_any(3) 
.RE
.PP

.SS "int pip_trywait (intpipid, int *retval)"

.PP
wait for the termination of a PiP task in a non-blocking way 
.PP
\fBParameters:\fP
.RS 4
\fIpipid\fP PiP ID to wait for\&. 
.br
\fIretval\fP Exit value of the terminated PiP task
.RE
.PP
\fBNote:\fP
.RS 4
This function can be used regardless to the PiP execution mode\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Return 0 on success\&. Return an error code on error\&. 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIEPERM\fP The caller is not the PiP root 
.br
\fIEDEADLK\fP The specified \fCpipid\fP is the PiP root 
.br
\fIESRCH\fP There is no running PiP task having the specified PiP ID
.RE
.PP
\fBSee Also:\fP
.RS 4
pip_exit(3), pip_wait(3), pip_wait_any(3), pip_trywait_any(3) 
.RE
.PP

.SS "int pip_wait_any (int *pipid, int *retval)"

.PP
wait for the termination of any PiP task 
.PP
\fBParameters:\fP
.RS 4
\fIpipid\fP PiP ID of terminated PiP task\&. 
.br
\fIretval\fP Exit value of the terminated PiP task
.RE
.PP
\fBNote:\fP
.RS 4
This function blocks until one of PiP tasks or ULPs terminates\&. 
.PP
This function can be used regardless to the PiP execution mode\&. However, only the least significant 2 bytes are effective\&. This is because of the compatibility with the \fCexit\fP glibc function\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Return 0 on success\&. Return an error code on error\&. 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIEPERM\fP The caller is not the PiP root 
.br
\fIESRCH\fP There is no running PiP task
.RE
.PP
\fBSee Also:\fP
.RS 4
pip_exit(3), pip_wait(3), pip_trywait(3), pip_trywait_any(3) 
.RE
.PP

.SS "int pip_trywait_any (int *pipid, int *retval)"

.PP
wait for the termination of any PiP task 
.PP
\fBParameters:\fP
.RS 4
\fIpipid\fP PiP ID of terminated PiP task\&. 
.br
\fIretval\fP Exit value of the terminated PiP task
.RE
.PP
\fBNote:\fP
.RS 4
This function never blocks\&. 
.PP
This function can be used regardless to the PiP execution mode\&. However, only the least significant 2 bytes are effective\&. This is because of the compatibility with the \fCexit\fP glibc function\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Return 0 on success\&. Return an error code on error\&. 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIEPERM\fP The caller is not the PiP root 
.br
\fIESRCH\fP There is no running PiP task
.RE
.PP
\fBSee Also:\fP
.RS 4
pip_exit(3), pip_wait(3), pip_trywait(3), pip_wait_any(3) 
.RE
.PP

.SS "int pip_kill (intpipid, intsignal)"

.PP
deliver a signal to a PiP task 
.PP
\fBParameters:\fP
.RS 4
\fIpipid\fP PiP ID of a target PiP task 
.br
\fIsignal\fP signal number to be delivered
.RE
.PP
\fBNote:\fP
.RS 4
Only the PiP task can be the target of the signal delivery\&. 
.PP
This function can be used regardless to the PiP execution mode\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Return 0 on success\&. Return an error code on error\&. 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIEPERM\fP PiP library is not yet initialized 
.br
\fIEINVAL\fP An invalid signal number or invalid PiP ID is specified 
.RE
.PP

.SS "int pip_get_id (intpipid, intptr_t *idp)"

.PP
deliver a process or thread ID defined by the system 
.PP
\fBParameters:\fP
.RS 4
\fIpipid\fP PiP ID of a target PiP task 
.br
\fIidp\fP a pointer to store the ID value
.RE
.PP
\fBNote:\fP
.RS 4
The returned object depends on the PiP mode\&. In the process mode it returns PID, in the thread mode it returns thread (\fCpthread_t\fP) associated with the PiP task 
.PP
This function can be used regardless to the PiP execution mode\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Return 0 on success\&. Return an error code on error\&. 
.RE
.PP

.SS "const char* pip_get_mode_str (void)"

.PP
get a string of the current execution mode 
.PP
\fBNote:\fP
.RS 4
This function can be used regardless to the PiP execution mode\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Return the name string of the current execution mode 
.RE
.PP

.SS "int pip_isa_root (void)"

.PP
check if calling PiP task is PiP root or not 
.PP
\fBReturns:\fP
.RS 4
Return true if the caller is the PiP root 
.RE
.PP

.SS "int pip_isa_task (void)"

.PP
check if calling PiP task is a PiP task or not 
.PP
\fBReturns:\fP
.RS 4
Return true if the caller is a PiP task 
.RE
.PP

.SS "int pip_isa_ulp (void)"

.PP
check if calling PiP task is a PiP ULP or not 
.PP
\fBReturns:\fP
.RS 4
Return true if the caller is a PiP ULP 
.RE
.PP

.SS "int pip_is_alive (intpipid)"

.PP
check if the specified PiP task is alive or not 
.PP
\fBParameters:\fP
.RS 4
\fIpipid\fP PiP ID to check
.RE
.PP
\fBReturns:\fP
.RS 4
Return true if the specified PiP task or ULP is alive (i\&.e\&., not yet terminated) and running 
.RE
.PP

.SS "int pip_spawn (char *filename, char **argv, char **envv, intcoreno, int *pipidp, pip_spawnhook_tbefore, pip_spawnhook_tafter, void *hookarg)"

.PP
spawn a PiP task (ULP API Version 1) 
.PP
\fBParameters:\fP
.RS 4
\fIfilename\fP The executable to run as a PiP task 
.br
\fIargv\fP Argument(s) for the spawned PiP task 
.br
\fIenvv\fP Environment variables for the spawned PiP task 
.br
\fIcoreno\fP Core number for the PiP task to be bound to\&. If \fCPIP_CPUCORE_ASIS\fP is specified, then the core binding will not take place\&. 
.br
\fIpipidp\fP Specify PiP ID of the spawned PiP task\&. If \fCPIP_PIPID_ANY\fP is specified, then the PiP ID of the spawned PiP task is up to the PiP library and the assigned PiP ID will be returned\&. 
.br
\fIbefore\fP Just before the executing of the spawned PiP task, this function is called so that file descriptors inherited from the PiP root, for example, can deal with\&. This is only effective with the PiP process mode\&. This function is called with the argument \fIhookarg\fP described below\&. 
.br
\fIafter\fP This function is called when the PiP task terminates for the cleanup purpose\&. This function is called with the argument \fIhookarg\fP described below\&. 
.br
\fIhookarg\fP The argument for the \fIbefore\fP and \fIafter\fP function call\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Return 0 on success\&. Return an error code on error\&.
.RE
.PP
This function is to spawn a PiP task\&. These functions are introduced to follow the programming style of conventional \fCfork\fP and \fCexec\fP\&. \fIbefore\fP function does the prologue found between the \fCfork\fP and \fCexec\fP\&. \fIafter\fP function is to free the argument if it is \fCmalloc()ed\fP\&. Note that the \fIbefore\fP and \fIafter\fP functions are called in the different \fIcontext\fP from the spawned PiP task\&. More specifically, any variables defined in the spawned PiP task cannot be accessible from the \fIbefore\fP and \fIafter\fP functions\&.
.PP
\fBNote:\fP
.RS 4
In theory, there is no reason to restrict for a PiP task to spawn another PiP task\&. However, the current implementation fails to do so\&. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for PiP - Process-in-Process from the source code\&.
